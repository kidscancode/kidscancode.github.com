<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>KCC Blog on KCC Blog </title>
      <generator uri="https://gohugo.io">Hugo</generator>
    <link>/blog/</link>
    <language>en-us</language>
    
    
    <updated>Sun, 13 May 2018 14:14:12 PDT</updated>
    
    <item>
      <title>Topdown Tank Battle: Part 7</title>
      <link>/blog/2018/05/godot3_tanks_part7/</link>
      <pubDate>Sun, 13 May 2018 14:14:12 PDT</pubDate>
      
      <guid>/blog/2018/05/godot3_tanks_part7/</guid>
      <description>&lt;p&gt;In this tutorial series, we&amp;rsquo;ll walk through the steps of building a 2D top-down tank game using Godot 3.0. The goal of the series is to introduce you to Godot&amp;rsquo;s workflow and show you various techniques that you can apply to your own projects.&lt;/p&gt;

&lt;p&gt;This is Part 7: Enemy tank health and explosions&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/VnfQa_A2880&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In the last part we added a healthbar for the player, so now we need to do the
same for the enemies. We&amp;rsquo;re also going to make some explosions!&lt;/p&gt;

&lt;h2 id=&#34;unit-health-display&#34;&gt;Unit health display&lt;/h2&gt;

&lt;p&gt;For the enemy units, we want the health to display as a small bar just above the
unit, which moves with them. Since every enemy tank will have one, and possibly
other things, we&amp;rsquo;re going to create this as a separate scene we can attach to any
object.&lt;/p&gt;

&lt;p&gt;Create a new scene with a &lt;code&gt;Node2D&lt;/code&gt; named &amp;ldquo;UnitDisplay&amp;rdquo; as its root. We&amp;rsquo;ll use this
to display the health and any other enemy data (armor, invincibility, etc.) that we
may add later in the game. Add a &lt;code&gt;TextureProgress&lt;/code&gt; as its child.&lt;/p&gt;

&lt;p&gt;Add the green bar texture to the &lt;em&gt;Texture/Progress&lt;/em&gt; property and set &lt;em&gt;Value&lt;/em&gt; to
&lt;code&gt;100&lt;/code&gt; so we can see it. Drag the bar so that it&amp;rsquo;s positioned above the &lt;code&gt;(0, 0)&lt;/code&gt;
point of the parent node.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_unit_healthbar1.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_unit_healthbar1.png&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Set the &lt;em&gt;Scale&lt;/em&gt; of the root node to &lt;code&gt;(0.5, 0.5)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;With this attached to the unit, it will follow the unit as it moves, but also
rotate along with its parent, which we don&amp;rsquo;t want. However, we can take care of
that in the script.&lt;/p&gt;

&lt;p&gt;In the script, we want to have a lot of the same behavior from the player healthbar,
such as changing color as it shrinks. Add a script and the code below, which is
very similar to that in the UI scene.&lt;/p&gt;

&lt;p&gt;We also want the bar to be hidden until the enemy first takes damage, so
we&amp;rsquo;ll make all the display elements hidden to begin, and the healthbar will
show if it drops below 100%.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node2D&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_red&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/barHorizontal_red_mid 200.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_green&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/barHorizontal_green_mid 200.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_yellow&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/barHorizontal_yellow_mid 200.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_children&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update_healthbar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;texture_progress&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_green&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;texture_progress&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_yellow&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;texture_progress&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_red&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We also want the node to ignore its parent&amp;rsquo;s rotation, so add the following:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;global_rotation&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now go to the &lt;code&gt;EnemyTank&lt;/code&gt; scene and attach an instance of the unit display.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_unit_healthbar2.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_unit_healthbar2.png&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We are already emittting the &lt;code&gt;health_changed&lt;/code&gt; signal in &lt;code&gt;Tank.gd&lt;/code&gt;, which the enemy
tank inherits from, so we just need to connect that signal. Connect it to the
UnitDisplay &lt;code&gt;update_healthbar()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;Run the game and verify that when you shoot the enemy, the healthbar appears and
reduces.&lt;/p&gt;

&lt;h2 id=&#34;explosions&#34;&gt;Explosions&lt;/h2&gt;

&lt;p&gt;Included in the tank art pack we&amp;rsquo;re using are two different styles of explosion
animations. We&amp;rsquo;ll use them by creating a separate scene and attaching it to anything
that needs to explode.&lt;/p&gt;

&lt;p&gt;Create a new scene with an &lt;code&gt;AnimatedSprite&lt;/code&gt; node and call it &amp;ldquo;Explosion&amp;rdquo;. Save it
in an &amp;ldquo;effects&amp;rdquo; folder. Add a new &lt;code&gt;SpriteFrames&lt;/code&gt; resource and in the SpriteFrames
panel, create two animations: &amp;ldquo;smoke&amp;rdquo; and &amp;ldquo;fire&amp;rdquo;, containing the respective
images.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_explosion_frames.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_explosion_frames.png&#34; width=&#34;450&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll start by adding the explosion to the Bullet scene. Set its &lt;em&gt;Scale&lt;/em&gt; to &lt;code&gt;(0.5, 0.5)&lt;/code&gt;
and click the &amp;ldquo;eye&amp;rdquo; symbol to make it hidden.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_explosion_bullet.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_explosion_bullet.png&#34; width=&#34;250&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We already created an &lt;code&gt;explode()&lt;/code&gt; method on the bullet. Now we&amp;rsquo;ll change that to
play the animation.&lt;/p&gt;

&lt;p&gt;We also need to connect the explosion&amp;rsquo;s &lt;code&gt;animation_finished&lt;/code&gt; signal so that we can
remove the bullet.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;explode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Sprite&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Explosion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;show&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Explosion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;smoke&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_on_Explosion_animation_finished&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;queue_free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_explosions1.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_explosions1.gif&#34; width=&#34;250&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;cursor&#34;&gt;Cursor&lt;/h2&gt;

&lt;p&gt;Finally, before we wrap up, let&amp;rsquo;s try using one of the custom cursor images from
the UI pack:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/crossair_black.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/crossair_black.png&#34; width=&#34;32&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;To use it as our mouse cursor, add the following line to &lt;code&gt;Map.gd&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_custom_mouse_cursor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/crossair_black.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CURSOR_ARROW&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That completes Part 7 of this series. In the next part we&amp;rsquo;ll start adding some
obstacles and items to the game.&lt;/p&gt;

&lt;p&gt;Please comment below with your questions and suggestions.&lt;/p&gt;

&lt;h3 id=&#34;a-href-https-github-com-kidscancode-topdown-tanks-releases-tag-part07-download-the-code-for-this-part-a&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/topdown_tanks/releases/tag/part07&#34;&gt;Download the code for this part&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godotengine.org/download&#34;&gt;Download Godot 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Me on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Topdown Tank Battle: Part 6</title>
      <link>/blog/2018/05/godot3_tanks_part6/</link>
      <pubDate>Sun, 06 May 2018 14:14:12 PDT</pubDate>
      
      <guid>/blog/2018/05/godot3_tanks_part6/</guid>
      <description>&lt;p&gt;In this tutorial series, we&amp;rsquo;ll walk through the steps of building a 2D top-down tank game using Godot 3.0. The goal of the series is to introduce you to Godot&amp;rsquo;s workflow and show you various techniques that you can apply to your own projects.&lt;/p&gt;

&lt;p&gt;This is Part 6: Tank damage and UI&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/87wtxNXx69Q&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In the last part, we added shooting, and the bullets are detecting contact
with the tanks. Now we need them to deal damage.&lt;/p&gt;

&lt;h2 id=&#34;dealing-damage&#34;&gt;Dealing damage&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;ll start with the &lt;code&gt;Tank.gd&lt;/code&gt; script by changing the &lt;code&gt;health&lt;/code&gt; export variable
to &lt;code&gt;max_health&lt;/code&gt;. This will be the &amp;ldquo;full&amp;rdquo; value, which can be configured per tank.
Then, add a new &lt;code&gt;var health&lt;/code&gt; which will track the current health value.&lt;/p&gt;

&lt;p&gt;Add code to the &lt;code&gt;_ready&lt;/code&gt; function to handle this. Note that when we emit the signal,
we&amp;rsquo;re passing a &lt;em&gt;percentage&lt;/em&gt; rather than the raw health value:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;health&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max_health&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;emit_signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;health_changed&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;health&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_health&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GunTimer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wait_time&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gun_cooldown&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Next, we add a method that will handle applying incoming damage:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;take_damage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;amount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;health&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;amount&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;emit_signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;health_changed&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;health&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_health&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;health&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;explode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;explode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;queue_free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;What we need to do now is make the bullet call that method when it collides.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;Bullet.gd&lt;/code&gt; script, we already have code that applies damage if the colliding
body can accept it:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_on_Bullet_body_entered&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;explode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;has_method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;take_damage&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;take_damage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;damage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Run the game and you should be able to destroy the enemy tanks if you hit them
enough times, depending on what health &amp;amp; damage values you assigned in the Inspector.&lt;/p&gt;

&lt;h2 id=&#34;ui-setup&#34;&gt;UI Setup&lt;/h2&gt;

&lt;p&gt;Now we need to display the player&amp;rsquo;s health, so we&amp;rsquo;ll create a HUD (&amp;ldquo;heads-up display&amp;rdquo;).
This will eventually display a variety of game data, but we&amp;rsquo;ll start with a bar
showing the player&amp;rsquo;s health.&lt;/p&gt;

&lt;p&gt;Create a new scene with the following nodes and save it in a &amp;ldquo;ui&amp;rdquo; folder:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CanvasLayer&lt;/code&gt; (&amp;ldquo;HUD&amp;rdquo;)

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MarginContainer&lt;/code&gt; (&amp;ldquo;Margin&amp;rdquo;)

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HBoxContainer&lt;/code&gt; (&amp;ldquo;Container&amp;rdquo;)

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;TextureRect&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;TextureProgress&lt;/code&gt; (&amp;ldquo;HealthBar&amp;rdquo;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The &lt;code&gt;MarginContainer&lt;/code&gt; keeps its children from getting too close to the edges of the
screen. In the &amp;ldquo;Layout&amp;rdquo; menu set it to &amp;ldquo;Full Rect&amp;rdquo; and in the Inspector set all
four of its &lt;em&gt;Custom Constants&lt;/em&gt; values to &lt;code&gt;20&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Drag the &lt;code&gt;res://assets/shield_silver.png&lt;/code&gt; image into the &lt;em&gt;Texture&lt;/em&gt; property of the
TextureRect.&lt;/p&gt;

&lt;p&gt;The TextureProgress node will handle the health display. It works by displaying a
portion of a given texture, determined by the &lt;code&gt;value&lt;/code&gt; property.&lt;/p&gt;

&lt;p&gt;Drag &lt;code&gt;res://assets/UI/barHorizontal_green_mid 200.png&lt;/code&gt; to the &lt;em&gt;Texture/Progress&lt;/em&gt; property
and &lt;code&gt;res://assets/UI/glassPanel_200.png&lt;/code&gt; to the &lt;em&gt;Texture/Over&lt;/em&gt; property. Set the
&lt;em&gt;Value&lt;/em&gt; to &lt;code&gt;75&lt;/code&gt; to see a portion of the green bar displayed.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_healthbar1.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_healthbar1.png&#34; width=&#34;350&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;ui-script&#34;&gt;UI Script&lt;/h2&gt;

&lt;p&gt;Add a script to the HUD with a function that updates the bar&amp;rsquo;s value to the one
given:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CanvasLayer&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update_healthbar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now that method needs to be connected to the player&amp;rsquo;s &lt;code&gt;health_changed&lt;/code&gt; signal.&lt;/p&gt;

&lt;p&gt;Add an instance of the HUD scene to the map scene. Click on the Player instance and
connect &lt;code&gt;health_changed&lt;/code&gt; to &lt;code&gt;update_healthbar&lt;/code&gt; in the HUD.&lt;/p&gt;

&lt;p&gt;Run the game and you should see the bar going down when bullets hit you.&lt;/p&gt;

&lt;h2 id=&#34;making-it-pretty&#34;&gt;Making it pretty&lt;/h2&gt;

&lt;p&gt;Now that we have the healthbar working, we&amp;rsquo;re going to add a little &amp;ldquo;juice&amp;rdquo; to make
it look more appealing. We&amp;rsquo;ll add a few effects:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Changing color from green -&amp;gt; yellow -&amp;gt; red as the value decreases&lt;/li&gt;
&lt;li&gt;A gradual animation when the value changes&lt;/li&gt;
&lt;li&gt;A flashing effect when hit&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;changing-color&#34;&gt;Changing color&lt;/h3&gt;

&lt;p&gt;The various colored bars are already in the &lt;code&gt;assets&lt;/code&gt; folder, we just need to load
them and apply them to the bar&amp;rsquo;s &lt;code&gt;texture_progress&lt;/code&gt; property. Add the following to
the hud script. Note: you can right-click on the file in the FileManager and choose
&amp;ldquo;Copy Path&amp;rdquo; rather than type out the file locations.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CanvasLayer&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_red&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/barHorizontal_red_mid 200.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_green&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/barHorizontal_green_mid 200.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_yellow&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/barHorizontal_yellow_mid 200.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_texture&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update_healthbar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_green&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_yellow&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_red&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;texture_progress&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Try running and the bar&amp;rsquo;s color should change as the value decreases.&lt;/p&gt;

&lt;h3 id=&#34;gradually-changing-value&#34;&gt;Gradually changing value&lt;/h3&gt;

&lt;p&gt;Next, we&amp;rsquo;re going to animate the change so that it doesn&amp;rsquo;t instantly jump to the
new value. We&amp;rsquo;ll do this with a &lt;code&gt;Tween&lt;/code&gt; node. Add one as a child of the HealthBar.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use the Tween to &lt;em&gt;interpolate&lt;/em&gt; the bar&amp;rsquo;s &lt;code&gt;value&lt;/code&gt; from its current value to
the new value.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CanvasLayer&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_red&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/barHorizontal_red_mid 200.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_green&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/barHorizontal_green_mid 200.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_yellow&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/barHorizontal_yellow_mid 200.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_texture&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update_healthbar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_green&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_yellow&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_red&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;texture_progress&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Tween&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;interpolate_property&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;mf&#34;&gt;0.2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Tween&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TRANS_LINEAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Tween&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EASE_IN_OUT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Tween&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Note that we don&amp;rsquo;t have to explicitly set the node&amp;rsquo;s &lt;code&gt;value&lt;/code&gt; because the tween
ends at the value we want.&lt;/p&gt;

&lt;h3 id=&#34;flashing-the-bar&#34;&gt;Flashing the bar&lt;/h3&gt;

&lt;p&gt;For the flashing bar animation, we&amp;rsquo;ll use &lt;code&gt;AnimationPlayer&lt;/code&gt;. Add one to the HUD and
create a new animation called &amp;ldquo;healthbar_flash&amp;rdquo;. Set the &lt;em&gt;Length&lt;/em&gt; to &lt;code&gt;0.2&lt;/code&gt; and the
&lt;em&gt;Steps&lt;/em&gt; to &lt;code&gt;0.05&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This animation will affect the &lt;code&gt;texture_progress&lt;/code&gt; property, so start by dragging the
red texture into that property and clicking the keyframe button. Now alternate keyframes
with the white and red textures until you reach the end of the 0.2 seconds.&lt;/p&gt;

&lt;p&gt;After the animation plays, the bar will be left with the red texture, so we&amp;rsquo;ll
connect the AnimationPlayer&amp;rsquo;s &lt;code&gt;animation_finished&lt;/code&gt; signal so that we can set the
bar back to its correct color.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CanvasLayer&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_red&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/barHorizontal_red_mid 200.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_green&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/barHorizontal_green_mid 200.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_yellow&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;preload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;res://assets/UI/barHorizontal_yellow_mid 200.png&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;bar_texture&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update_healthbar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_green&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_yellow&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_red&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;texture_progress&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Tween&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;interpolate_property&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
            &lt;span class=&#34;mf&#34;&gt;0.2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Tween&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TRANS_LINEAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Tween&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EASE_IN_OUT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Tween&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AnimationPlayer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;healthbar_flash&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_on_AnimationPlayer_animation_finished&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;anim_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;anim_name&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;healthbar_flash&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Margin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HealthBar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;texture_progress&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar_texture&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That completes Part 6 of this series. In the next part we&amp;rsquo;ll continue adding
visuals with individual unit healthbars on the enemy tanks and explosions for the bullets.&lt;/p&gt;

&lt;p&gt;Please comment below with your questions and suggestions.&lt;/p&gt;

&lt;h3 id=&#34;a-href-https-github-com-kidscancode-topdown-tanks-releases-tag-part06-download-the-code-for-this-part-a&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/topdown_tanks/releases/tag/part06&#34;&gt;Download the code for this part&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godotengine.org/download&#34;&gt;Download Godot 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Me on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Topdown Tank Battle: Part 5</title>
      <link>/blog/2018/04/godot3_tanks_part5/</link>
      <pubDate>Thu, 26 Apr 2018 14:14:12 PDT</pubDate>
      
      <guid>/blog/2018/04/godot3_tanks_part5/</guid>
      <description>&lt;p&gt;In this tutorial series, we&amp;rsquo;ll walk through the steps of building a 2D top-down tank game using Godot 3.0. The goal of the series is to introduce you to Godot&amp;rsquo;s workflow and show you various techniques that you can apply to your own projects.&lt;/p&gt;

&lt;p&gt;This is Part 5: Enemy shooting and improved enemy movement&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/kStPQXu3X7c&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In the last part, we added shooting to the player, so this time we need to do the
same for the enemy tank. But first, there&amp;rsquo;s a small fix we need to make:&lt;/p&gt;

&lt;p&gt;In the enemy tank&amp;rsquo;s &lt;code&gt;Detect&lt;/code&gt; area, we attached a &lt;code&gt;CollisionShape2D&lt;/code&gt; with a circle shape.
The problem is that when we instance the enemies, the shape is &lt;em&gt;shared&lt;/em&gt; between them.
This means that when we set that shape&amp;rsquo;s radius in &lt;code&gt;_ready()&lt;/code&gt; all the tanks wind
up with the same size, ignoring our &lt;code&gt;detect_radius&lt;/code&gt; property.&lt;/p&gt;

&lt;p&gt;To fix this, clear the shape from the &lt;code&gt;CollisionShape2D&lt;/code&gt; in the scene, and change
the &lt;code&gt;EnemyTank.gd&lt;/code&gt; code like so:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;circle&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CircleShape2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DetectRadius&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CollisionShape2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;circle&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DetectRadius&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CollisionShape2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;detect_radius&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This ensures that each enemy gets its own unique shape resource, set to its
desired size.&lt;/p&gt;

&lt;h2 id=&#34;enemy-bullets&#34;&gt;Enemy Bullets&lt;/h2&gt;

&lt;p&gt;First, we create a new &lt;code&gt;EnemyBullet&lt;/code&gt; scene exactly like the player bullet we made
in the last part. The only difference should be which texture you use for the
appearance. Make sure you set the collision layer/mask properties. The enemy
bullet should be in the &amp;ldquo;bullets&amp;rdquo; layer, and its mask should see &amp;ldquo;environment&amp;rdquo;
and &amp;ldquo;player&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;After saving the scene, make sure to drop it in the EnemyTank&amp;rsquo;s &lt;em&gt;Bullet&lt;/em&gt;
property.&lt;/p&gt;

&lt;h3 id=&#34;aiming&#34;&gt;Aiming&lt;/h3&gt;

&lt;p&gt;We already have our enemy tank aiming its turret at the player. Now we want it to
fire, but only when it&amp;rsquo;s pointing towards the player (i.e. the angle between the
turret and the player is small).&lt;/p&gt;

&lt;p&gt;In the enemy&amp;rsquo;s &lt;code&gt;_process()&lt;/code&gt; function, we already have a direction vector pointing
at the player, &lt;code&gt;target_dir&lt;/code&gt;, and one representing the turret&amp;rsquo;s direction, &lt;code&gt;current_dir&lt;/code&gt;.
To check the angle between them, we can use the dot product.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Quick review of dot product:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The dot product of two unit vectors (vectors of length &lt;code&gt;1&lt;/code&gt;), is a number between
&lt;code&gt;-1&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. &lt;code&gt;0&lt;/code&gt; means the two vectors are exactly 90 degrees apart, and &lt;code&gt;1&lt;/code&gt; means
they are pointing in the same direction. For a review of vector math, including
dot product, see &lt;a href=&#34;http://docs.godotengine.org/en/latest/tutorials/math/vector_math.html&#34;&gt;http://docs.godotengine.org/en/latest/tutorials/math/vector_math.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If the dot product of the two vectors is close to &lt;code&gt;1&lt;/code&gt; then the tank is aiming near
the player, and should attempt to shoot. Update the enemy tank&amp;rsquo;s code:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;target_dir&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;global_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;normalized&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;current_dir&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Turret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Turret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_rotation&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current_dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;linear_interpolate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target_dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;turret_speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target_dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;current_dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We defined &lt;code&gt;shoot()&lt;/code&gt; in the base &lt;code&gt;Tank&lt;/code&gt; script, so the bullet will be emitted using
the &lt;code&gt;shoot&lt;/code&gt; signal just like the player&amp;rsquo;s bullet.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;Main&lt;/code&gt; script already has a function, &lt;code&gt;_on_Tank_shoot&lt;/code&gt;, that can receive an
emitted bullet. Connect each enemy instance&amp;rsquo;s &lt;code&gt;shoot&lt;/code&gt; signal to that function.&lt;/p&gt;

&lt;h2 id=&#34;enemy-movement&#34;&gt;Enemy movement&lt;/h2&gt;

&lt;p&gt;We can also make some improvements to the enemy&amp;rsquo;s movement. Right now, if we drive
in front of the enemy, the collision is a bit glitchy as the two bodies try and
slide around each other.&lt;/p&gt;

&lt;p&gt;Instead, let&amp;rsquo;s make the enemy tank hit the brakes if there&amp;rsquo;s an obstacle in front
of it. We can accomplish this by adding a &lt;code&gt;RayCast2D&lt;/code&gt; to the enemy tank scene.&lt;/p&gt;

&lt;p&gt;Set the &lt;em&gt;Enabled&lt;/em&gt; property to &amp;ldquo;On&amp;rdquo; (it&amp;rsquo;s off by default), and the &amp;ldquo;Cast To&amp;rdquo; to &lt;code&gt;(100, 0)&lt;/code&gt;
so that it projects ahead of the tank.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_raycast.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_raycast.png&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;Collision Mask&lt;/em&gt; of the raycast should be set to &amp;ldquo;environment&amp;rdquo;, &amp;ldquo;enemies&amp;rdquo;, and &amp;ldquo;player&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Now we also need the enemy to change its speed. In &lt;code&gt;Tank.gd&lt;/code&gt;, change the &lt;code&gt;speed&lt;/code&gt;
export variable to &lt;code&gt;max_speed&lt;/code&gt;. Note: this means we need to change the variable name
in the player&amp;rsquo;s script too!&lt;/p&gt;

&lt;p&gt;Add &lt;code&gt;var speed&lt;/code&gt; to the top of the enemy script. This will now be our &amp;ldquo;current&amp;rdquo; speed,
which may change over time. If the raycast detects something, &lt;code&gt;speed&lt;/code&gt; will ramp down
to &lt;code&gt;0&lt;/code&gt; and if it doesn&amp;rsquo;t, it will ramp up to &lt;code&gt;max_speed&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We can accomplish this &amp;ldquo;ramping&amp;rdquo; effect using GDScript&amp;rsquo;s linear interpolation function: &lt;code&gt;lerp&lt;/code&gt;.
Update the enemy tank&amp;rsquo;s &lt;code&gt;control()&lt;/code&gt; function:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;control&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LookAhead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_colliding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lerp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ramp&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;down&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lerp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max_speed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.05&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ramp&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;up&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;bp&#34;&gt;max&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PathFollow2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;other&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;movement&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;pass&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Run the scene and try it out. If you drive the player in front of the enemy tank,
it should stop moving.&lt;/p&gt;

&lt;p&gt;However, we still have a small problem: if the collision happens with an offset or
around a corner, the ray may not &amp;ldquo;see&amp;rdquo; anything. We can improve the obstacle detection
if we use two raycasts instead of one:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_raycast2.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_raycast2.png&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you click on the &lt;code&gt;LookAhead&lt;/code&gt; node and press &lt;em&gt;Ctrl+D&lt;/em&gt; you can duplicate the node
with all of its settings. Adjust the &lt;em&gt;Position&lt;/em&gt; of each so that one is shifted
&lt;code&gt;30&lt;/code&gt; pixels up and the other  down.&lt;/p&gt;

&lt;p&gt;Now we just need to make sure we check both of them:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LookAhead1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_colliding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;or&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LookAhead2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_colliding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;ll do it for Part 5 of this series. In the next part we&amp;rsquo;ll continue to work
on the shooting by adding some effects (explosions) and handle damage.&lt;/p&gt;

&lt;p&gt;Please comment below with your questions and suggestions.&lt;/p&gt;

&lt;h3 id=&#34;a-href-https-github-com-kidscancode-topdown-tanks-releases-tag-part05-download-the-code-for-this-part-a&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/topdown_tanks/releases/tag/part05&#34;&gt;Download the code for this part&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godotengine.org/download&#34;&gt;Download Godot 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Me on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Topdown Tank Battle: Part 4</title>
      <link>/blog/2018/04/godot3_tanks_part4/</link>
      <pubDate>Thu, 19 Apr 2018 14:14:12 PDT</pubDate>
      
      <guid>/blog/2018/04/godot3_tanks_part4/</guid>
      <description>&lt;p&gt;In this tutorial series, we&amp;rsquo;ll walk through the steps of building a 2D top-down tank game using Godot 3.0. The goal of the series is to introduce you to Godot&amp;rsquo;s workflow and show you various techniques that you can apply to your own projects.&lt;/p&gt;

&lt;p&gt;This is Part 4: Player shooting&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/UKfzBnfh4Ak&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;h3 id=&#34;physics-layers&#34;&gt;Physics Layers&lt;/h3&gt;

&lt;p&gt;As we add more objects to the game, the interactions between them are going to be
more and more complex. We&amp;rsquo;ll use Godot&amp;rsquo;s &lt;em&gt;physics layer&lt;/em&gt; system to organize what
other objects can &amp;ldquo;see&amp;rdquo; and interact with.&lt;/p&gt;

&lt;p&gt;To make it easier to track layers, you can assign names to them in &lt;em&gt;Project Settings -&amp;gt;
Layer Names&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_physics_layers.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_physics_layers.png&#34; width=&#34;450&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Screenshot: setting layers&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Here are the layer settings you should use for the object&amp;rsquo;s we&amp;rsquo;ve made so far:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Object&lt;/th&gt;
&lt;th&gt;Layer(s)&lt;/th&gt;
&lt;th&gt;Mask&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Player&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;player&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;environment&lt;/code&gt;, &lt;code&gt;enemies&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;EnemyTank&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;enemies&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;environment&lt;/code&gt;, &lt;code&gt;player&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Enemy DetectRadius&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;enemies&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;player&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Note that we haven&amp;rsquo;t put &lt;code&gt;enemies&lt;/code&gt; in the enemy tank&amp;rsquo;s mask. This way if we have
two enemy tanks that have overlapping paths, they&amp;rsquo;ll just drive through each other.
We may change this later, but for now, it&amp;rsquo;ll keep things simple.&lt;/p&gt;

&lt;p&gt;Also, since we set the &lt;code&gt;DetectRadius&lt;/code&gt; area&amp;rsquo;s mask to &lt;code&gt;players&lt;/code&gt; it won&amp;rsquo;t &amp;ldquo;see&amp;rdquo; any
other objects. This means we can simplify the code a little bit, changing this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_on_DetectRadius_body_entered&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;to this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_on_DetectRadius_body_entered&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;bullet-scene&#34;&gt;Bullet Scene&lt;/h2&gt;

&lt;p&gt;As with the tanks, we&amp;rsquo;re going to make a master bullet scene that will be inherited
by any bullet types we may make. Here&amp;rsquo;s the scene setup:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Area2D&lt;/code&gt; named &amp;ldquo;Bullet&amp;rdquo;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Sprite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CollisionShape2D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Timer&lt;/code&gt; named &amp;ldquo;Lifetime&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Area2Ds are convenient for projectiles because they don&amp;rsquo;t need physics or collisions,
they just need to detect &lt;em&gt;contact&lt;/em&gt;. When the bullet contacts an object, it will
explode and deal damage.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;Lifetime&amp;rdquo; timer will be used to destroy the bullet after a given time.&lt;/p&gt;

&lt;p&gt;Save the scene in a &amp;ldquo;bullets&amp;rdquo; folder, where we&amp;rsquo;ll also save the objects that inherit
from it.&lt;/p&gt;

&lt;h3 id=&#34;bullet-script&#34;&gt;Bullet script&lt;/h3&gt;

&lt;p&gt;Attach a script, which will serve as the shared code for all projectiles.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Area2D&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;speed&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;damage&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;lifetime&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_direction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_position&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_direction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Lifetime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wait_time&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lifetime&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_direction&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;explode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;queue_free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Later we&amp;rsquo;ll give the bullet a fancy-looking explosion, but for now we&amp;rsquo;ll just
delete it. We also need to attach two signals:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_on_Bullet_body_entered&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;explode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;has_method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;take_damage&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;take_damage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;damage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_on_Lifetime_timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;explode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The bullet might hit a variety of bodies. Some of them will take damage, and some
won&amp;rsquo;t. By using &lt;code&gt;has_method()&lt;/code&gt; we can deal the bullet&amp;rsquo;s damage to any body that
accepts it.&lt;/p&gt;

&lt;h2 id=&#34;player-bullet&#34;&gt;Player Bullet&lt;/h2&gt;

&lt;p&gt;For the player bullet, create a new inherited scene and use one of the images
from the spritesheet.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_player_bullet.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_player_bullet.png&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Note that most of the bullets in the spritesheet are drawn facing &lt;em&gt;left&lt;/em&gt;. To correct this,
set the Sprite&amp;rsquo;s &lt;em&gt;Rotation Degrees&lt;/em&gt; to &lt;code&gt;180&lt;/code&gt; (alternatively, you can use &lt;em&gt;Flip H&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Next, add a collision shape. You can use a rectangle or a capsule here - it won&amp;rsquo;t really make
much difference as long as you don&amp;rsquo;t scale incorrectly.&lt;/p&gt;

&lt;p&gt;Attach a script that extends from &lt;code&gt;res://bullets/Bullet.gd&lt;/code&gt;, although we don&amp;rsquo;t have
anything extra to add to the player bullet right now. Don&amp;rsquo;t forget to set the &lt;em&gt;Speed&lt;/em&gt;,
&lt;em&gt;Damage&lt;/em&gt;, and &lt;em&gt;Lifetime&lt;/em&gt; properties in the Inspector. I&amp;rsquo;m using &lt;code&gt;750&lt;/code&gt;, &lt;code&gt;10&lt;/code&gt;, and &lt;code&gt;0.5&lt;/code&gt;
respectively.&lt;/p&gt;

&lt;p&gt;The next step is to make the &amp;ldquo;shoot&amp;rdquo; action instance a bullet.&lt;/p&gt;

&lt;h3 id=&#34;bullet-handling&#34;&gt;Bullet Handling&lt;/h3&gt;

&lt;p&gt;This is where a lot of beginners run into trouble. If you instance a bullet and
add it as a child of the player, you&amp;rsquo;ll see something odd. When you move or turn after
firing, the bullet&amp;rsquo;s path changes too!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_child_bullets.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_child_bullets.gif&#34; width=&#34;250&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is because a child node&amp;rsquo;s transform follows its parent&amp;rsquo;s. One common solution
is to make a &amp;ldquo;container&amp;rdquo; using a &lt;code&gt;Node&lt;/code&gt;. Since &lt;code&gt;Node&lt;/code&gt; has no 2d positional information,
its children will not inherit any transforms. However, the problem with this is that
since the bullets are still part of the object&amp;rsquo;s scene, if the object is deleted, so
are the bullets.&lt;/p&gt;

&lt;p&gt;In order to avoid this, the bullet should be independent of the object that fired
it. The tank should shoot, and then no longer have any responsibility for or
knowledge of the bullet. We can accomplish this by using a signal, &amp;ldquo;emitting&amp;rdquo;
the bullet, and letting some other node (our main scene in this case) take responsibility
for managing the bullet.&lt;/p&gt;

&lt;p&gt;We already made a &lt;code&gt;Bullet&lt;/code&gt; export variable on the player, so drag the PlayerBullet
into this in the Inspector.&lt;/p&gt;

&lt;p&gt;Since both the enemy and the player tank will be firing, we can add the shooting
code to the generic Tank.gd script.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;signal&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shoot&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;can_shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;can_shoot&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
        &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GunTimer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;dir&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Turret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;emit_signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shoot&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bullet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Turret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Muzzle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;When the shoot function is triggered, it emits the &lt;code&gt;shoot&lt;/code&gt; signal and passes
along the location and direction where the bullet needs to start.&lt;/p&gt;

&lt;p&gt;Add this to the &lt;code&gt;control()&lt;/code&gt; function of the Player.gd script:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_just_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;click&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now if you run the game, clicking will emit the signal with the bullet. Even though
we haven&amp;rsquo;t connected the signal to anything, the player doesn&amp;rsquo;t &amp;ldquo;know&amp;rdquo; there&amp;rsquo;s any
problem. You can even run the player scene alone, so that it has no parent, and it
will continue to function even though the bullets don&amp;rsquo;t actually appear.&lt;/p&gt;

&lt;h3 id=&#34;map-script&#34;&gt;Map script&lt;/h3&gt;

&lt;p&gt;In the map script, we need a function to handle the emitted bullets. This function
doesn&amp;rsquo;t care whether it was the player or any other object that&amp;rsquo;s firing. It just
needs to accept the incoming bullet and add it to the scene.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_on_Tank_shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bullet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_direction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bullet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;add_child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_direction&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now in the map&amp;rsquo;s player instance, we can connect the &lt;code&gt;shoot&lt;/code&gt; signal to this new
function.&lt;/p&gt;

&lt;p&gt;Run the scene and you should be able to shoot as expected.
&lt;a href=&#34;/blog/blog/img/tanks_player_shoot.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_player_shoot.gif&#34; width=&#34;250&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;ll do it for Part 4 of this series. In the next part we&amp;rsquo;ll make the enemy
tanks shoot as well, and create another enemy type: a machine-gun turret.&lt;/p&gt;

&lt;p&gt;Please comment below with your questions and suggestions.&lt;/p&gt;

&lt;h3 id=&#34;a-href-https-github-com-kidscancode-topdown-tanks-releases-tag-part04-download-the-code-for-this-part-a&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/topdown_tanks/releases/tag/part04&#34;&gt;Download the code for this part&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godotengine.org/download&#34;&gt;Download Godot 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Me on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Topdown Tank Battle: Part 3</title>
      <link>/blog/2018/04/godot3_tanks_part3/</link>
      <pubDate>Thu, 12 Apr 2018 14:12:12 PDT</pubDate>
      
      <guid>/blog/2018/04/godot3_tanks_part3/</guid>
      <description>&lt;p&gt;In this tutorial series, we&amp;rsquo;ll walk through the steps of building a 2D top-down tank game using Godot 3.0. The goal of the series is to introduce you to Godot&amp;rsquo;s workflow and show you various techniques that you can apply to your own projects.&lt;/p&gt;

&lt;p&gt;This is Part 3: Enemy tank movement&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/soUBTPD4Iu8&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;ve been following the previous sections, you now how have a map with a
player tank that can drive around and aim its turret. Now we&amp;rsquo;re going to add an
enemy tank and give it a &amp;ldquo;patrol&amp;rdquo; behavior so it will drive around the scene
following a given path.&lt;/p&gt;

&lt;h2 id=&#34;enemy-tank-scene&#34;&gt;Enemy tank scene&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;re going to start by making another &lt;em&gt;Inherited Scene&lt;/em&gt; from Tank.tscn, like we
did previously with the player tank. Add a texture to the body and turret sprites.
I chose the red tank:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_enemy_tank.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_enemy_tank.png&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Remember you&amp;rsquo;ll have to set the &lt;em&gt;Offset&lt;/em&gt; of the turret sprite so that it will
rotate around the correct point (depending on which texture you use).&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll attach a script extending &lt;code&gt;res://tanks/Tank.gd&lt;/code&gt; so that we get all the
common tank code. Again, for the tank&amp;rsquo;s movement, we need to supply the code in
the &lt;code&gt;control()&lt;/code&gt; function.&lt;/p&gt;

&lt;p&gt;There are many possible movement behaviors we could implement for the enemy tank,
such as path following, chasing, flocking, etc. In fact, later we&amp;rsquo;ll probably
want to have different tanks using different ones. To begin, however, we&amp;rsquo;re going
to use path following: the tank will &amp;ldquo;patrol&amp;rdquo; around a given predefined path using
&lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_path2d.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_path_2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_path_2d&#34;&gt;&lt;/svg&gt;&lt;code&gt;Path2D&lt;/code&gt;&lt;/a&gt; and &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_pathfollow2d.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_path_follow_2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_path_follow_2d&#34;&gt;&lt;/svg&gt;&lt;code&gt;PathFollow2D&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Since we want to be able to assign other behaviors to the tank, we&amp;rsquo;ll check to see if
it has been attached to a PathFollow2D, and use the pathfollow code only in that case.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;res://tanks/Tank.gd&amp;#34;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;onready&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;control&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PathFollow2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;# other movement code&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;pass&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now if we add an enemy tank to a path, it will automatically follow it. Don&amp;rsquo;t forget
to set the Tank&amp;rsquo;s &lt;em&gt;Speed&lt;/em&gt; in the Inspector.&lt;/p&gt;

&lt;h2 id=&#34;creating-paths&#34;&gt;Creating paths&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;Path2D&lt;/code&gt; lets you draw a curve that a node can follow. Add a &amp;ldquo;Paths&amp;rdquo; &lt;code&gt;Node2D&lt;/code&gt;
to the map to hold them (we will eventually add a bunch of these), and add a &lt;code&gt;Path2D&lt;/code&gt; to that.&lt;/p&gt;

&lt;p&gt;Hopefully you&amp;rsquo;ve used Path2D before. If you haven&amp;rsquo;t, there&amp;rsquo;s a great example of
using and drawing them in the &lt;a href=&#34;http://docs.godotengine.org/en/latest/getting_started/step_by_step/your_first_game.html&#34; target=&#34;_blank&#34;&gt;official Godot tutorial&lt;/a&gt;,
which I also have a &lt;a href=&#34;https://www.youtube.com/playlist?list=PLsk-HSGFjnaFutTDzgik2KMRl6W1JxFgD&#34; target=&#34;_blank&#34;&gt;video series about&lt;/a&gt;._&lt;/p&gt;

&lt;p&gt;Draw a path that circles around part of your map, like so:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_path1.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_path1.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Note that the light blue color of the path in the editor is very hard to see against the
road/grass tileset. While you&amp;rsquo;re drawing, you can darken the map by changing its &lt;em&gt;Modulate&lt;/em&gt;
property.&lt;/p&gt;

&lt;p&gt;Now add a &lt;code&gt;PathFollow2D&lt;/code&gt; node to the path. By changing this node&amp;rsquo;s &lt;code&gt;offset&lt;/code&gt; property, you
can move it along the path. Then add an instance of the EnemyTank as a child of the
PathFollow2D.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_path_nodes.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_path_nodes.png&#34; width=&#34;250&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Hit play on the scene and check it out. The tank moves along the path, but there&amp;rsquo;s
a problem at the corners:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_path2.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_path2.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The sudden direction change looks very unnatural, so we need a way to smoothly
turn around corners.&lt;/p&gt;

&lt;h2 id=&#34;smoothing-the-path&#34;&gt;Smoothing the path&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s redraw the path, this time cutting across the corners diagonally:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_path_corners.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_path_corners.png&#34; width=&#34;350&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_path3.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_path3.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is an improvement, but we can do a lot better.&lt;/p&gt;

&lt;p&gt;Select the path and in the toolbar, click the &amp;ldquo;Select Control Points&amp;rdquo; button:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_path_control_points.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_path_control_points.png&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Then click and drag from any point on the path to create a control point you can use to curve the line. If you&amp;rsquo;re careful, you can align the path along the road&amp;rsquo;s centerline.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_path4.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_path4.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;collisions&#34;&gt;Collisions&lt;/h2&gt;

&lt;p&gt;Now that we have the tank moving around the path correctly, we can address a
different problem. Play the game and position your player tank on the path in
front of the enemy tank. It will stop moving when it hits, but then something
very unexpected will happen:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_path5.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_path5.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s happening is that the PathFollow2D is continuing to move, even though the
tank can&amp;rsquo;t. As a result, the tank is getting offset from the path. We need to
make sure the tank always sticks with the path follower.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;control&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PathFollow2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_path6.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_path6.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;enemy-turret&#34;&gt;Enemy turret&lt;/h2&gt;

&lt;p&gt;The next thing we need the enemy to do is rotate its turret to aim at the player.
However, we don&amp;rsquo;t want the enemy to have an infinite range, so we need a way to
only detect the player when it&amp;rsquo;s in range.&lt;/p&gt;

&lt;h3 id=&#34;detecting-the-player&#34;&gt;Detecting the player&lt;/h3&gt;

&lt;p&gt;Add an &lt;code&gt;Area2D&lt;/code&gt; to the player called &amp;ldquo;DetectRadius&amp;rdquo; and give it a &lt;code&gt;CollisionShape2D&lt;/code&gt;.
Don&amp;rsquo;t assign a shape, though - we&amp;rsquo;ll do that in code so it can be customized per
enemy.&lt;/p&gt;

&lt;p&gt;Add variables to set the turret rotation speed and the DetectRadius&amp;rsquo; side, as well
as one to track its target. Then in &lt;code&gt;_ready()&lt;/code&gt; we&amp;rsquo;ll create the collision circle.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;turret_speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;detect_radius&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;400&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;null&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;circle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CircleShape2D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DetectRadius&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CollisionShape2D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;circle&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DetectRadius&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CollisionShape2D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;detect_radius&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;1&lt;/code&gt; and &lt;code&gt;400&lt;/code&gt; are good default values to start with. Turn on &amp;ldquo;Visible Collision
Shapes&amp;rdquo; in the Debug menu and run the game to verify that your collision circle
is being set.&lt;/p&gt;

&lt;p&gt;To detect the player, connect the DetectRadius&amp;rsquo; &lt;code&gt;body_entered&lt;/code&gt; and &lt;code&gt;body_exited&lt;/code&gt;
signals.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_on_DetectRadius_body_entered&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Player&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_on_DetectRadius_body_exited&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;null&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Now the tank can acquire and lose the player target.&lt;/p&gt;

&lt;h3 id=&#34;aiming-at-the-player&#34;&gt;Aiming at the player&lt;/h3&gt;

&lt;p&gt;Aiming the turret can now be done by comparing the direction to the target to the
turret&amp;rsquo;s current direction and moving it at the turret&amp;rsquo;s speed. We can use
Vector2&amp;rsquo;s &lt;code&gt;linear_interpolate&lt;/code&gt; method for that.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;global_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;normalized&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Turret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Turret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_rotation&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current_dir&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;linear_interpolate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target_dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;turret_speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Run the game and check that the aiming is working. Try using different values of &lt;code&gt;turret_speed&lt;/code&gt; to
see what the effect is. Higher values make the enemy tank very quick!&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;To sum up, here&amp;rsquo;s the full &amp;ldquo;EnemyTank.gd&amp;rdquo; script:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;res://tanks/Tank.gd&amp;#34;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;onready&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;turret_speed&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;detect_radius&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;null&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;circle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CircleShape2D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DetectRadius&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CollisionShape2D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;circle&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DetectRadius&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CollisionShape2D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;detect_radius&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;control&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PathFollow2D&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_offset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;# other movement code&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;pass&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;global_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;normalized&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Turret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Turret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_rotation&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current_dir&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;linear_interpolate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target_dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;turret_speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_on_DetectRadius_body_entered&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Player&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_on_DetectRadius_body_exited&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;null&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;That&amp;rsquo;ll do it for Part 3 of this series. In the next part we&amp;rsquo;ll add a projectile
and give the player and enemy tanks the ability to fire.&lt;/p&gt;

&lt;p&gt;Please comment below with your questions and suggestions.&lt;/p&gt;

&lt;h3 id=&#34;a-href-https-github-com-kidscancode-topdown-tanks-releases-tag-part03-download-the-code-for-this-part-a&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/topdown_tanks/releases/tag/part03&#34;&gt;Download the code for this part&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godotengine.org/download&#34;&gt;Download Godot 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Me on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Topdown Tank Battle: Part 2</title>
      <link>/blog/2018/04/godot3_tanks_part2/</link>
      <pubDate>Fri, 06 Apr 2018 08:12:12 PDT</pubDate>
      
      <guid>/blog/2018/04/godot3_tanks_part2/</guid>
      <description>&lt;p&gt;In this tutorial series, we&amp;rsquo;ll walk through the steps of building a 2D top-down tank game using Godot 3.0. The goal of the series is to introduce you to Godot&amp;rsquo;s workflow and show you various techniques that you can apply to your own projects.&lt;/p&gt;

&lt;p&gt;This is Part 2: adding terrain using TileMap.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/hcYZm9SWjwg&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In the &lt;a href=&#34;/blog/blog/2018/04/godot3_tanks_part1/&#34;&gt;last step&lt;/a&gt; we created a player tank
and implemented its movement and aiming. In this part we&amp;rsquo;re going to create the map that
the player will drive around on.&lt;/p&gt;

&lt;p&gt;To do this, we&amp;rsquo;ll use the TileMap node.&lt;/p&gt;

&lt;h2 id=&#34;tilemap&#34;&gt;TileMap&lt;/h2&gt;

&lt;p&gt;A &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_tilemap.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_tile_map&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_tile_map&#34;&gt;&lt;/svg&gt;TileMap&lt;/a&gt;
node allows you to quickly design levels by &amp;ldquo;painting&amp;rdquo; tiles onto a grid.&lt;/p&gt;

&lt;p&gt;In order to use a TileMap, you have to assign a &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_tileset.html&#34; target=&#34;_blank&#34;&gt;TileSet&lt;/a&gt; resource. We want to use the tiles from this image:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/terrainTiles_retina.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/terrainTiles_retina.png&#34; width=&#34;450&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Since these source tiles are laid out in a regular grid, it will be easier to write a brief script to &amp;ldquo;slice&amp;rdquo; them into a TileSet than to cut them up manually.&lt;/p&gt;

&lt;h3 id=&#34;automatically-creating-the-tileset&#34;&gt;Automatically creating the TileSet&lt;/h3&gt;

&lt;p&gt;Create a new scene with a Node root and add a Sprite node with the image above as its &lt;em&gt;Texture&lt;/em&gt; property. Save it in a new &amp;ldquo;terrain&amp;rdquo; folder and call it TileSetMaker.tscn. It&amp;rsquo;s likely we&amp;rsquo;ll want to use this
script again to generate other TileSets, so this way we can repeat the process by using another texture
in this scene.&lt;/p&gt;

&lt;p&gt;Add a script with the following code:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tile_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;onready&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Sprite&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tex_width&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tile_size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tex_height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tile_size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ts&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TileSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tex_width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tex_height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;region&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Rect2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tile_size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tile_size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                               &lt;span class=&#34;n&#34;&gt;tile_size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tile_size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;ts&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;create_tile&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;ts&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tile_set_texture&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;ts&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tile_set_region&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;region&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ResourceSaver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;save&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;res://terrain/terrain_tiles.tres&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This script starts by getting the pixel size of the image and dividing by the tile size, so that we know how many tiles we have. Then it&amp;rsquo;s a matter of looping through the tiles one by one and creating a tile in the new TileSet object. Note that tiles need to have a unique &lt;code&gt;id&lt;/code&gt;, so we&amp;rsquo;re generating one using &lt;code&gt;x + y * 10&lt;/code&gt;. Then we add the texture and region for the tile.&lt;/p&gt;

&lt;p&gt;Finally, using &lt;code&gt;ResourceSaver&lt;/code&gt; you can save a given resource to disk.&lt;/p&gt;

&lt;p&gt;You can use this script for any tilesheet arranged into a grid - just set the appropriate &lt;code&gt;tile_size&lt;/code&gt; value. Run the scene and the resulting TileSet is saved in the &amp;ldquo;terrain&amp;rdquo; folder and ready to use.&lt;/p&gt;

&lt;h3 id=&#34;level-structure&#34;&gt;Level structure&lt;/h3&gt;

&lt;p&gt;Eventually we will probably want to have multiple maps, but their functionality will probably be the same - display the tiles and spawn any map objects we need. For now, we&amp;rsquo;ll just make a generic map and get that working.&lt;/p&gt;

&lt;p&gt;Make a new scene with a Node2D called &amp;ldquo;Map01&amp;rdquo; and give it a TileMap child. Drag &lt;code&gt;res://terrain/terrain_tiles.tres&lt;/code&gt; into the &lt;em&gt;Tile Set&lt;/em&gt; property. Set the &lt;em&gt;Cell/Size&lt;/em&gt; property to &lt;code&gt;(128, 128)&lt;/code&gt; to match the size of the tiles. Save the map in a &amp;ldquo;maps&amp;rdquo; folder.&lt;/p&gt;

&lt;p&gt;Draw the map by choosing a tile from the window on the left and left-clicking in the editor window to place it. Right-click removes a tile. Draw the level as large as you like - we&amp;rsquo;ll add a scrolling camera soon.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_draw_level.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_draw_level.png&#34; width=&#34;450&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;One note: I&amp;rsquo;m naming the TileMap &amp;ldquo;Ground&amp;rdquo; because one of the nice things you can do with TileMaps is layer them. You can then have different types of objects in each layer.&lt;/p&gt;

&lt;p&gt;When you&amp;rsquo;re finished drawing your level, add an instance of the &lt;code&gt;Player&lt;/code&gt; to the scene. Run the scene and you&amp;rsquo;ll see that we really need to have a scrolling camera!&lt;/p&gt;

&lt;h2 id=&#34;scrolling-camera&#34;&gt;Scrolling Camera&lt;/h2&gt;

&lt;p&gt;Go back to your player scene and add a &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_camera2d.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_camera_2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_camera_2d&#34;&gt;&lt;/svg&gt;Camera2D&lt;/a&gt; node. Set its &lt;em&gt;Current&lt;/em&gt; property to &amp;ldquo;On&amp;rdquo; and then run your map scene again.&lt;/p&gt;

&lt;p&gt;Much better, but there&amp;rsquo;s still a problem when we reach the edge of the map. We don&amp;rsquo;t want
to see that grey area &amp;ldquo;past&amp;rdquo; the edge of the map:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_camera1.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_camera1.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;camera-limits&#34;&gt;Camera limits&lt;/h3&gt;

&lt;p&gt;Camera2D has properties that define its maximum and minimum allowed x/y values. You can find
them under &lt;em&gt;Limit&lt;/em&gt; in the Inspector.&lt;/p&gt;

&lt;p&gt;However, we want those limits set dynamically based on the size of the map we&amp;rsquo;re on. Attach
a new script to the map scene. &lt;strong&gt;Important:&lt;/strong&gt; Name this script &amp;ldquo;Map.gd&amp;rdquo; because even if we
make more than one map, they&amp;rsquo;re all going to use this same script.&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node2D&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;set_camera_limits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;set_camera_limits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map_limits&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Ground&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_used_rect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map_cellsize&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Ground&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cell_size&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Camera2D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;limit_left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map_limits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map_cellsize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Camera2D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;limit_right&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map_limits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map_cellsize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Camera2D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;limit_top&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map_limits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map_cellsize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Camera2D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;limit_bottom&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map_limits&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map_cellsize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;At runtime, we call the camera limit function. It uses the camera&amp;rsquo;s &lt;code&gt;get_used_rect()&lt;/code&gt;
method to find a rectangle enclosing the &lt;em&gt;used&lt;/em&gt; cells in the map. We also need the
cell size so we can convert to pixels. Then, it&amp;rsquo;s a matter of setting each camera
limit to the corresponding map&amp;rsquo;s edge coordinate.&lt;/p&gt;

&lt;p&gt;Run your map scene again and you should see the camera scrolling stop when you reach
the edge of the map.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That&amp;rsquo;ll do it for Part 2 of this series. Next time, we&amp;rsquo;ll add an enemy tank and make
it drive around the map too!&lt;/p&gt;

&lt;p&gt;Please comment below with your questions and suggestions.&lt;/p&gt;

&lt;h3 id=&#34;a-href-https-github-com-kidscancode-topdown-tanks-releases-tag-part02-download-the-code-for-this-part-a&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/topdown_tanks/releases/tag/part02&#34;&gt;Download the code for this part&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godotengine.org/download&#34;&gt;Download Godot 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Me on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Topdown Tank Battle: Part 1</title>
      <link>/blog/2018/04/godot3_tanks_part1/</link>
      <pubDate>Mon, 02 Apr 2018 08:12:12 PDT</pubDate>
      
      <guid>/blog/2018/04/godot3_tanks_part1/</guid>
      <description>&lt;p&gt;In this tutorial series, we&amp;rsquo;ll walk through the steps of building a 2D top-down tank game using Godot 3.0. The goal of the series is to introduce you to Godot&amp;rsquo;s workflow and show you various techniques that you can apply to your own projects.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/sQ1FpD0DYF8&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; I&amp;rsquo;ll try to keep the written versions in sync with the video tutorials as much as possible, but the writeups tend to take quite a bit longer and generate a fraction of the response and feedback.&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_gameplay.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_gameplay.png&#34; width=&#34;400&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here are a few of the features we have planned:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;User and AI controlled tanks that move and shoot&lt;/li&gt;
&lt;li&gt;Keyboard/mouse and touch controls&lt;/li&gt;
&lt;li&gt;Tile-based level maps&lt;/li&gt;
&lt;li&gt;Game UI including HUD and menus&lt;/li&gt;
&lt;li&gt;Multiple levels/maps&lt;/li&gt;
&lt;li&gt;Upgrades and powerups&lt;/li&gt;
&lt;li&gt;Bosses/boss levels&lt;/li&gt;
&lt;li&gt;Visual effects such as screen-shake, particles, and shaders&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This list will very likely change over time, as other ideas are suggested or just seem to make sense. It&amp;rsquo;s exploratory programming at its finest.&lt;/p&gt;

&lt;p&gt;Note that this game is being developed as we go, so expect the occasional mistake or development dead-end requiring some backtracking. &lt;em&gt;Refactoring&lt;/em&gt; is a useful technique of its own, and we&amp;rsquo;ll likely need to make use of it liberally along the way.&lt;/p&gt;

&lt;p&gt;The latest code for the project will always be available at &lt;a href=&#34;https://github.com/kidscancode/topdown_tanks&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/topdown_tanks&#34;&gt;https://github.com/kidscancode/topdown_tanks&lt;/a&gt;&lt;/a&gt;, with releases for each part available here: &lt;a href=&#34;https://github.com/kidscancode/topdown_tanks/releases&#34; target=&#34;_blank&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/topdown_tanks/releases&#34;&gt;https://github.com/kidscancode/topdown_tanks/releases&lt;/a&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;project-setup&#34;&gt;Project Setup&lt;/h2&gt;

&lt;p&gt;Open &lt;em&gt;Project -&amp;gt; Project Settings&lt;/em&gt; and in the &lt;em&gt;Rendering/Quality&lt;/em&gt; section set &lt;em&gt;Use Pixel Snap&lt;/em&gt; to &amp;ldquo;On&amp;rdquo;. In &lt;em&gt;Display/Window&lt;/em&gt; set &lt;em&gt;Mode&lt;/em&gt; to &amp;ldquo;2d&amp;rdquo; and &lt;em&gt;Aspect&lt;/em&gt; to &amp;ldquo;keep&amp;rdquo;. We&amp;rsquo;ll see later how these settings work when resizing the game window.&lt;/p&gt;

&lt;p&gt;The control scheme will be WASD for movement, and mouse for aim/shoot. We&amp;rsquo;ll define these inputs by clicking on the &amp;ldquo;Input Map&amp;rdquo; tab in &lt;em&gt;Project Settings&lt;/em&gt; and adding the following actions:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tank_input_actions.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tank_input_actions.png&#34; width=&#34;400&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We also need to change the default import settings for textures. By default, &amp;ldquo;filtering&amp;rdquo; is on, which results in a blurred effect, especially when using pixel art. If we change the defaults before downloading the game assets, they&amp;rsquo;ll be imported with the right settings.&lt;/p&gt;

&lt;p&gt;Click on the Godot icon (icon.png) and click the &amp;ldquo;Import&amp;rdquo; tab next to &amp;ldquo;Scene&amp;rdquo; in the upper-right. From the &amp;ldquo;Preset&amp;rdquo; menu, select &amp;ldquo;2D Pixel&amp;rdquo; and &amp;ldquo;Set as Default for &amp;lsquo;Texture&amp;rsquo;&amp;rdquo;, then click the &amp;ldquo;Reimport&amp;rdquo; button.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tex_import_settings.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tex_import_settings.png&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Whenever you make changes to a resource&amp;rsquo;s import settings, you have to reimport the resource for them to take effect.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now we can download the assets and unzip them in the project folder.&lt;/p&gt;

&lt;h3 id=&#34;assets&#34;&gt;Assets&lt;/h3&gt;

&lt;p&gt;For this project, we&amp;rsquo;re using Kenney&amp;rsquo;s &lt;a href=&#34;http://kenney.nl/assets/topdown-tanks-redux&#34; target=&#34;_null&#34;&gt;Top-down Tanks Redux&lt;/a&gt; art pack. You can download it there, or get
it directly from my project here: &lt;a href=&#34;https://github.com/kidscancode/topdown_tanks/tree/master/assets&#34; target=&#34;_null&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/topdown_tanks/tree/master/assets&#34;&gt;https://github.com/kidscancode/topdown_tanks/tree/master/assets&lt;/a&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you look closely at my version of the texture atlas, you&amp;rsquo;ll notice we&amp;rsquo;ve made one small change from the original download. In the &amp;ldquo;assets&amp;rdquo; folder you&amp;rsquo;ll find a texture atlas called &amp;ldquo;onlyObjects_retina_rotated.png&amp;rdquo;. In the original art pack the tanks (and many of the other assets) are all drawn facing downwards. Because Godot&amp;rsquo;s 2D orientation uses the x-axis (facing right) as the zero angle, we&amp;rsquo;d have to rotate all our sprites when adding them. Instead, with the original atlas rotated, we can use them as they are.&lt;/p&gt;

&lt;h2 id=&#34;tank-scene&#34;&gt;Tank Scene&lt;/h2&gt;

&lt;p&gt;Eventually there will be several kinds of tank: player-controlled tanks, enemy tanks, boss tanks, etc. They&amp;rsquo;ll likely share a lot of properties and functionality, so using inheritance is probably a good idea. However, since we&amp;rsquo;re just starting out, rather than try and assume all the functionality we&amp;rsquo;ll eventually need, we&amp;rsquo;re going to start simple and refactor if necessary when we add more complex behaviors.&lt;/p&gt;

&lt;p&gt;Create the tank scene with the following nodes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;KinematicBody2D (&amp;ldquo;Tank&amp;rdquo;)

&lt;ul&gt;
&lt;li&gt;Sprite (the tank&amp;rsquo;s body)&lt;/li&gt;
&lt;li&gt;CollisionShape2D&lt;/li&gt;
&lt;li&gt;Sprite (&amp;ldquo;Turret&amp;rdquo; - the tank&amp;rsquo;s gun)

&lt;ul&gt;
&lt;li&gt;Position2D (&amp;ldquo;Muzzle&amp;rdquo; - the spawn point for bullets)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Timer (&amp;ldquo;GunTimer&amp;rdquo;) - the cooldown for shooting&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Save this scene in a folder called &amp;ldquo;tanks&amp;rdquo;. This is where you&amp;rsquo;ll save all the tank-related
scenes and scripts.&lt;/p&gt;

&lt;h3 id=&#34;tank-script&#34;&gt;Tank script&lt;/h3&gt;

&lt;p&gt;This code will be shared between all the different kinds of tanks. Switch to the
Script editor and click &lt;em&gt;File -&amp;gt; New&lt;/em&gt;. Set the script to extend &lt;code&gt;KinematicBody2D&lt;/code&gt;
and save it in the tanks folder.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KinematicBody2D&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;signal&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;health_changed&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;signal&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dead&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PackedScene&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bullet&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rotation_speed&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gun_cooldown&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;health&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;can_shoot&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alive&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
        &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;GunTimer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wait_time&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gun_cooldown&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;control&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;pass&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;alive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;control&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;move_and_slide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The code and variables should be pretty self-explanatory. The &lt;code&gt;control()&lt;/code&gt; function
is where the specific code will go for each type of tank. For example, the player
will use input actions to set its velocity, while an enemy tank will use some sort
of pathfinding AI.&lt;/p&gt;

&lt;h2 id=&#34;player-scene&#34;&gt;Player Scene&lt;/h2&gt;

&lt;p&gt;Create the player scene by clicking &lt;em&gt;Scene -&amp;gt; New Inherited Scene&lt;/em&gt; and choosing
&lt;code&gt;Tank.tscn&lt;/code&gt;. Rename the root node &amp;ldquo;Player&amp;rdquo; and save the scene. You now have a player
scene with all the necessary nodes ready to go.&lt;/p&gt;

&lt;p&gt;The first thing you need to do is add textures to the sprite nodes. Drag &lt;code&gt;res://assets/onlyObjects_retina_rotated.png&lt;/code&gt; from the FileSystem dock and drop it in the body sprite&amp;rsquo;s &lt;em&gt;Texture&lt;/em&gt; property.&lt;/p&gt;

&lt;p&gt;To select a subset of the atlas (a &lt;em&gt;region&lt;/em&gt;) click the &lt;em&gt;Region&lt;/em&gt; property to &amp;ldquo;On&amp;rdquo;, then click &amp;ldquo;Texture Region&amp;rdquo; at the bottom of the window to open the region selection panel.&lt;/p&gt;

&lt;p&gt;In this window you can select the portion of the image you want to use for your sprite. Choose one of the tank bodies that doesn&amp;rsquo;t have a gun attached. You may find it helpful to enable &amp;ldquo;Pixel Snap&amp;rdquo; at the top of the window.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_texture_region.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_texture_region.png&#34; width=&#34;450&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Do the same thing with the &lt;code&gt;Turret&lt;/code&gt; sprite to select a gun image for your tank.&lt;/p&gt;

&lt;p&gt;The only problem with the turret is that if rotated, it will rotate around its center, which doesn&amp;rsquo;t look correct. Select the &lt;code&gt;Turret&lt;/code&gt; and increase the &lt;code&gt;x&lt;/code&gt; value of its &lt;em&gt;Offset&lt;/em&gt;. For the example here, &lt;code&gt;(20, 0)&lt;/code&gt; works well, but if you chose a different gun image you may have to adjust.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tank_turret_offset.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tank_turret_offset.png&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Next, move the Muzzle marker to a position just in front of the barrel of the gun. This is the spawn point for bullets. A &lt;em&gt;Position&lt;/em&gt; of &lt;code&gt;(60, 0)&lt;/code&gt; works well with this particular barrel texture.&lt;/p&gt;

&lt;p&gt;Finally, add a rectangular collision shape to the &lt;code&gt;CollisionShape2D&lt;/code&gt; and scale it to cover the tank&amp;rsquo;s body. Remember to use the size handles on the shape itself, not the outer Node2D indicator.&lt;/p&gt;

&lt;h3 id=&#34;player-script&#34;&gt;Player script&lt;/h3&gt;

&lt;p&gt;Attach a script to the Player node and next to the &lt;em&gt;Inherits&lt;/em&gt; field, click the folder icon and choose &lt;code&gt;res://tanks/Tank.gd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_inherit_script.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_inherit_script.png&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Add the following code to the new script:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;res://tanks/Tank.gd&amp;#34;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;control&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Turret&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;look_at&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_global_mouse_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rot_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;turn_right&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;rot_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;turn_left&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;rot_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rotation_speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rot_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;forward&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;back&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Since we&amp;rsquo;re inheriting the code from &amp;ldquo;Tank.gd&amp;rdquo; we only need to define the &lt;code&gt;control()&lt;/code&gt; function to make things work. The key inputs rotate the tank and move it forward/backward in the facing direction. Meanwhile, the turret will always point at the mouse pointer by using &lt;code&gt;look_at()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Run the scene and try driving your tank around!&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/tanks_movement1.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/tanks_movement1.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;That wraps up Part 1 of this series. In the next part, we&amp;rsquo;ll lay out a basic level using TileMaps.&lt;/p&gt;

&lt;p&gt;Please comment below with your questions and suggestions.&lt;/p&gt;

&lt;h3 id=&#34;a-href-https-github-com-kidscancode-topdown-tanks-releases-tag-part01-download-the-code-for-this-part-a&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/topdown_tanks/releases/tag/part01&#34;&gt;Download the code for this part&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godotengine.org/download&#34;&gt;Download Godot 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Me on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Godot 3.0: Visibility with Ray-casting</title>
      <link>/blog/2018/03/godot3_visibility_raycasts/</link>
      <pubDate>Sat, 10 Mar 2018 08:12:12 -0700</pubDate>
      
      <guid>/blog/2018/03/godot3_visibility_raycasts/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/blog/blog/img/godot_logo.png&#34; width=&#34;450&#34;&gt;&lt;/p&gt;

&lt;p&gt;This tutorial shows how to use the ray-casting feature of Godot&amp;rsquo;s physics engine (not the RayCast2D node) to make entities that can&amp;rsquo;t see through walls.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use a TileMap for walls and create some rotating turrets that look for the player and shoot when they can see it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; This is not a beginner-level tutorial. It assumes you have a general knowledge of Godot. If you&amp;rsquo;re not there yet, start &lt;a href=&#34;http://docs.godotengine.org/en/latest/getting_started/step_by_step/intro_to_the_editor_interface.html&#34; target=&#34;_blank&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/lNADi7kTDJ4&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;We&amp;rsquo;re going to skip over the basic setup of the project and just summarize the setup here.&lt;/p&gt;

&lt;p&gt;You can download the starting project here: &lt;a href=&#34;/blog/blog/img/raycasting_demo_start.zip&#34;&gt;raycasting_demo_start.zip&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;At the start, we have a &lt;code&gt;Main&lt;/code&gt; scene that contains a TileMap and instances of the &lt;code&gt;Player&lt;/code&gt; and a &lt;code&gt;Turret&lt;/code&gt;.  The &lt;code&gt;Player&lt;/code&gt; is a &lt;code&gt;KinematicBody2D&lt;/code&gt; with basic 8-way movement using &lt;code&gt;move_and_slide()&lt;/code&gt;. See the project for the code, and see &lt;a href=&#34;/blog/blog/2018/02/godot3_kinematic2d/&#34;&gt;Using KinematicBody2D&lt;/a&gt; for more details on how this type of node works.&lt;/p&gt;

&lt;p&gt;We have the &lt;code&gt;Turret&lt;/code&gt; node setup to detect the player and fire.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/raycast_start.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/raycast_start.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;We use the turret&amp;rsquo;s Area2D to detect the player entering and exiting. The code for the &lt;code&gt;Turret&lt;/code&gt; looks like this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KinematicBody2D&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;detect_radius&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# size of the visibility circle&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fire_rate&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# delay time (s) between bullets&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PackedScene&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bullet&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vis_color&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;867&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;91&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;247&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;# who are we shooting at?&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;can_shoot&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# dim the sprite when not active&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Sprite&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;self_modulate&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# set the collision area&amp;#39;s radius&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CircleShape2D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;detect_radius&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Visibility&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CollisionShape2D&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ShootTimer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;wait_time&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fire_rate&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# if there&amp;#39;s a target, rotate towards it and fire&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;can_shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bullet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;global_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rand_range&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;0.05&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.05&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;get_parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;add_child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;can_shoot&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;false&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ShootTimer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_draw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# display the visibility area&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;draw_circle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;detect_radius&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vis_color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_on_Visibility_body_entered&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# connect this to the &amp;#34;body_entered&amp;#34; signal&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Sprite&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;self_modulate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_on_Visibility_body_exited&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# connect this to the &amp;#34;body_exited&amp;#34; signal&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;body&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;null&lt;/span&gt;
        &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Sprite&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;self_modulate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.2&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_on_ShootTimer_timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;can_shoot&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This is fine in an open area, but if the player is behind a wall, the turret can still &amp;ldquo;see&amp;rdquo; them. This is what we are going to fix.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/raycast_wall_ex.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/raycast_wall_ex.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;h2 id=&#34;ray-casting&#34;&gt;Ray-casting&lt;/h2&gt;

&lt;p&gt;Godot has a &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_raycast2d.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_ray_cast_2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_ray_cast_2d&#34;&gt;&lt;/svg&gt; RayCast2D&lt;/a&gt; node that can report collisions. However, there are situations where using the node will not be practical. For example, if you need to cast a large number of rays dynamically, it is very inefficient to instance nodes for each one, especially since the physics engine is going to do the actual collision detection anyway.&lt;/p&gt;

&lt;p&gt;Fortunately, we can access the physics server&amp;rsquo;s state directly and use it for collision checks. We can do this using&lt;/p&gt;

&lt;p&gt;&lt;code&gt;get_world_2d().direct_space_state&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Once we have access to the space, we can use the &lt;code&gt;intersect_ray()&lt;/code&gt; function to cast a ray. If a collision occurs, the function will return useful information about the collision.&lt;/p&gt;

&lt;p&gt;Change the code in &lt;code&gt;_physics_process()&lt;/code&gt; to the following:&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;aim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Instead of just shooting the target, we&amp;rsquo;re going to try and aim at them first. We also want to be able to visualize what&amp;rsquo;s going on, so add a &lt;code&gt;var hit_pos&lt;/code&gt; at the top - this variable will store the position where the raycast hit so that we can draw it.&lt;/p&gt;

&lt;p&gt;In the &lt;code&gt;aim()&lt;/code&gt; function we&amp;rsquo;re going to cast the ray. The function works like this:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;intersect_ray(start, end, exceptions, mask)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;start&lt;/code&gt; and &lt;code&gt;end&lt;/code&gt; coordinates need to be in &lt;em&gt;global coordinates&lt;/em&gt;. &lt;code&gt;exceptions&lt;/code&gt; lets us list any objects we want the ray to ignore and &lt;code&gt;mask&lt;/code&gt; defines the collision layers they ray should scan.&lt;/p&gt;

&lt;p&gt;In the turret&amp;rsquo;s case the ray will be cast from the turret to the player&amp;rsquo;s position. We need to list the turret itself as an exception, or else the ray won&amp;rsquo;t travel at all!. Finally, since the &lt;code&gt;Turret&lt;/code&gt; node&amp;rsquo;s collision mask is set to only detect walls (environment) and the player, we can use that same mask for the ray.&lt;/p&gt;

&lt;p&gt;Here is what the &lt;code&gt;aim()&lt;/code&gt; function looks like:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;space_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_world_2d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;direct_space_state&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;space_state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;intersect_ray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                    &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;collision_mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;hit_pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;collider&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;Player&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Sprite&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;self_modulate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;can_shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;If the ray intersects something, it could either be a wall or the player. Only if it&amp;rsquo;s the player do we shoot as before. Also, move the &lt;code&gt;self_modulate&lt;/code&gt; from &lt;code&gt;_on_Visibility_body_entered()&lt;/code&gt; and put it here, so that the turret only lights up red when the player can be seen.&lt;/p&gt;

&lt;p&gt;We also stored the coordinates of the collision in &lt;code&gt;hit_pos&lt;/code&gt; so that we can draw the ray. Add the following to &lt;code&gt;_draw()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_draw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;draw_circle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;detect_radius&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vis_color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;draw_line&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hit_pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;laser_color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;draw_circle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hit_pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;laser_color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/raycast_aim1.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/raycast_aim1.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Looking good! You can see the red line of the ray, and when it runs into a wall the turret remains inactive. However, we now have a different problem:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/raycast_aim2.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/raycast_aim2.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;casting-multiple-rays&#34;&gt;Casting Multiple Rays&lt;/h2&gt;

&lt;p&gt;Since the ray is being cast toward the player&amp;rsquo;s &lt;code&gt;position&lt;/code&gt;, which is the center of the player&amp;rsquo;s sprite, the turret can&amp;rsquo;t &amp;ldquo;see&amp;rdquo; the player even when it should. To solve this, we need to cast rays to the player&amp;rsquo;s corners, not its center. Now we will have a list of hits, so we must make &lt;code&gt;hit_pos&lt;/code&gt; an array.&lt;/p&gt;

&lt;p&gt;To get the player&amp;rsquo;s four corner positions, we use the &lt;code&gt;extents&lt;/code&gt; of its collision shape. We&amp;rsquo;re also subtracting &lt;code&gt;(5, 5)&lt;/code&gt; to give a little leeway for the width of the bullets. The four corners are labeled &lt;code&gt;nw&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;, &lt;code&gt;se&lt;/code&gt;, and &lt;code&gt;sw&lt;/code&gt;, and a ray is cast towards each:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;hit_pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;space_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_world_2d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;direct_space_state&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;CollisionShape2D&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;extents&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;se&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ne&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ne&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;se&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;space_state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;intersect_ray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                     &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;collision_mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;hit_pos&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;collider&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Player&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Sprite&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;self_modulate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;can_shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And we need to change the draw function to use the array of hits:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_draw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;draw_circle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;detect_radius&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vis_color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hit&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hit_pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;draw_circle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;laser_color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;draw_line&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hit&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;laser_color&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/raycast_aim3.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/raycast_aim3.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re almost there, but now you will notice that when the turret has a straight shot towards the player, it still shoots at the player&amp;rsquo;s corner! We should add the center position back in, and check it &lt;em&gt;first&lt;/em&gt;.  We also can add a &lt;code&gt;break&lt;/code&gt; statement to the loop - if one of the rays hits, we don&amp;rsquo;t need to continue checking the rest of them. The final &lt;code&gt;aim()&lt;/code&gt; function looks like this:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;hit_pos&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;space_state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_world_2d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;direct_space_state&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;CollisionShape2D&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;extents&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;se&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ne&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target_extents&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ne&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;se&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;space_state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;intersect_ray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                     &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;collision_mask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;hit_pos&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;collider&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Player&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Sprite&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;self_modulate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;can_shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Hopefully, you&amp;rsquo;ll find this technique useful for your own projects. A similar process can be used for laser shots instead of bullets (draw the line for a brief time, or try using Line2D instead of &lt;code&gt;draw_line()&lt;/code&gt; for a different effect). You can implement ricochets by taking the ray collision point and casting another ray from that point at the reflected angle.&lt;/p&gt;

&lt;p&gt;If you enjoyed this and found it useful, please let me know in the comments below. I&amp;rsquo;m always happy to hear requests and suggestions for other gamedev-related material.&lt;/p&gt;

&lt;h3 id=&#34;a-href-blog-img-raycasting-demo-finish-zip-download-the-finished-project-a&#34;&gt;&lt;a href=&#34;/blog/blog/img/raycasting_demo_finish.zip&#34;&gt;Download the finished project&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godotengine.org/download&#34;&gt;Download Godot 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Me on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Godot 3.0: Using KinematicBody2D</title>
      <link>/blog/2018/02/godot3_kinematic2d/</link>
      <pubDate>Tue, 13 Feb 2018 03:12:12 -0700</pubDate>
      
      <guid>/blog/2018/02/godot3_kinematic2d/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/blog/blog/img/godot_logo.png&#34; width=&#34;450&#34;&gt;&lt;/p&gt;

&lt;p&gt;Godot offers a number of collision objects to provide both collision detection and response. Trying to decide which one to use for your project can be confusing. You can avoid problems and simplify development if you understand how each each works and what their pros and cons are. In this tutorial, we&amp;rsquo;ll look at the &lt;code&gt;KinematicBody2D&lt;/code&gt; node and show some examples of how it can be used.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;!-- You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/Z0w9Jviq57c&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt; --&gt;

&lt;h1 id=&#34;introduction-physics-bodies&#34;&gt;Introduction: Physics bodies&lt;/h1&gt;

&lt;p&gt;In game development you often need to know when two objects in the game space intersect or come into contact. This is known as &lt;em&gt;collision detection&lt;/em&gt;. When a collision is detected, you typically want something to happen. This is known as &lt;em&gt;collision response&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Godot offers three kinds of physics bodies, grouped under the &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_physicsbody2d.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;PhysicsBody2D&lt;/code&gt;&lt;/a&gt; type:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;StaticBody2D&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A static body is one that is not moved by the physics engine. It participates in collision detection, but does not move in response to the collision. This type of body is most often used for objects that are part of the environment or that do not need to have any dynamic behavior.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RigidBody2D&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This is the node that implements simulated 2D physics. You do not control a &lt;code&gt;RigidBody2D&lt;/code&gt; directly, but instead you apply forces to it (gravity, impulses, etc.) and the physics engine calculates the resulting movement. See &lt;a href=&#34;/blog/blog/2017/12/godot3_kyn_rigidbody1/&#34;&gt;Godot 3.0: Rigid Bodies&lt;/a&gt; for more information.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;KinematicBody2D&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A body that provides collision detection, but no physics. All movement must be implemented in code.&lt;/p&gt;

&lt;h2 id=&#34;collision-shapes&#34;&gt;Collision shapes&lt;/h2&gt;

&lt;p&gt;A physics body can hold any number of &lt;code&gt;Shape2D&lt;/code&gt; objects as children. These shapes are used to define the object&amp;rsquo;s collision bounds and to detect contact with other objects.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; In order to detect collisions, at least one &lt;code&gt;Shape2D&lt;/code&gt; must be assigned to the object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The most common way to assign a shape is by adding a &lt;code&gt;CollisionShape2D&lt;/code&gt; or &lt;code&gt;CollisionPolygon2D&lt;/code&gt; as a child of the object. These nodes allow you to draw the shape directly in the editor workspace.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Be careful to never scale your collision shapes in the editor. The &lt;code&gt;Scale&lt;/code&gt; property in the Inspector should remain at &lt;code&gt;(1, 1)&lt;/code&gt;. When changing the size of the collision shape, you should always use the shape&amp;rsquo;s handles, &lt;em&gt;not&lt;/em&gt; the &lt;code&gt;Node2D&lt;/code&gt; scale handles. Changing the scale can result in unexpected collision behavior.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;!player_coll_shape.png&lt;/p&gt;

&lt;h2 id=&#34;collision-layers-and-masks&#34;&gt;Collision Layers and Masks&lt;/h2&gt;

&lt;p&gt;One of the most powerful but frequently misunderstood collision features in Godot is the collision layer system. This system allows you to build up very complex interactions between a variety of objects. The key concepts are &lt;em&gt;layers&lt;/em&gt; and &lt;em&gt;masks&lt;/em&gt;. Each CollisionObject2D has 32 different physics layers it can interact with.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at each of the properties in turn:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;collision_layer&lt;/code&gt;&lt;/strong&gt;
describes the layers that the object appears &lt;em&gt;in&lt;/em&gt;. By default, all bodies are on layer &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;collision_mask&lt;/code&gt;&lt;/strong&gt;
describes what layers the body will &lt;em&gt;scan&lt;/em&gt; for collisions. If an object isn&amp;rsquo;t in one of the mask layers, the body will ignore it. By default, all bodies scan layer &lt;code&gt;1&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can also assign names to layers. In &amp;ldquo;Project Settings&amp;rdquo;, look for the &amp;ldquo;Layer Names -&amp;gt; 2D Physics&amp;rdquo; section:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/k2d_layer_names.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/k2d_layer_names.png&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A body&amp;rsquo;s layer properties can be configured via code, or directly in the Inspector:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/k2d_layer_example.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/k2d_layer_example.png&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Example:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;You have three nodes with the following configuration:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Layers&lt;/th&gt;
&lt;th&gt;Mask&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Player&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2, 3&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Enemy&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;2&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Coin&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;3&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;1&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In this scenario, the &lt;code&gt;Player&lt;/code&gt; node would detect collisions with both &lt;code&gt;Enemy&lt;/code&gt; and &lt;code&gt;Coin&lt;/code&gt; nodes (because they are in layers it scans). However, &lt;code&gt;Enemy&lt;/code&gt; and &lt;code&gt;Coin&lt;/code&gt; nodes would not detect each other, because they only scan layers they are &lt;em&gt;not&lt;/em&gt; in.&lt;/p&gt;

&lt;h1 id=&#34;kinematic-bodies&#34;&gt;Kinematic Bodies&lt;/h1&gt;

&lt;p&gt;&lt;code&gt;KinematicBody2D&lt;/code&gt; is for implementing bodies that are to be controlled via code. They detect collisions with other bodies when moving, but are not affected by engine physics properties like gravity or friction. While this means that you have to write some code to create their behavior, it also means you have more precise control over how they move and react.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; A &lt;code&gt;KinematicBody2D&lt;/code&gt; can be affected by gravity and other forces, but you must calculate the movement in code. The physics engine will not move a &lt;code&gt;KinematicBody2D&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;movement-and-collision&#34;&gt;Movement and collision&lt;/h2&gt;

&lt;p&gt;When moving a &lt;code&gt;KinematicBody2D&lt;/code&gt;, you should not set its &lt;code&gt;position&lt;/code&gt; directly. Instead, you use the &lt;code&gt;move_and_collide()&lt;/code&gt; or &lt;code&gt;move_and_slide()&lt;/code&gt; methods. These methods move the body along a given vector and will instantly stop if a collision is detected with another body. After a KinematicBody2D has collided, any &lt;em&gt;collision response&lt;/em&gt; must be coded manually.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Kinematic body movement should only be done in the &lt;code&gt;_physics_process()&lt;/code&gt; callback.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;move-and-collide&#34;&gt;move_and_collide&lt;/h3&gt;

&lt;p&gt;This method takes one parameter: a &lt;code&gt;Vector2&lt;/code&gt; indicating the body&amp;rsquo;s relative movement. Typically, this is your velocity vector multiplied by the frame timestep (&lt;code&gt;delta&lt;/code&gt;). If the engine detects a collision anywhere along this vector, the body will immediately stop moving. If this happens, the method will return a &lt;code&gt;KinematicCollision2D&lt;/code&gt; object.&lt;/p&gt;

&lt;h4 id=&#34;kinematiccollision2d&#34;&gt;KinematicCollision2D&lt;/h4&gt;

&lt;p&gt;When a KinematicBody2D detects a collision, Godot provides a &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_kinematiccollision2d.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;KinematicCollision2D&lt;/code&gt;&lt;/a&gt; object. This object contains data about the collision and the colliding object. Using this data you can calculate your collision response.&lt;/p&gt;

&lt;h3 id=&#34;move-and-slide&#34;&gt;move_and_slide&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;move_and_slide()&lt;/code&gt; method is intended to simplify the collision response in the common case where you want one body to slide along the other. This is especially useful in platformers or top-down games, for example.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; &lt;code&gt;move_and_slide()&lt;/code&gt; automatically calculates frame-based movement using &lt;code&gt;delta&lt;/code&gt;. Do &lt;em&gt;not&lt;/em&gt; multiply your velocity vector by &lt;code&gt;delta&lt;/code&gt; before passing it to &lt;code&gt;move_and_slide()&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;In addition to the velocity vector, &lt;code&gt;move_and_slide&lt;/code&gt; takes a number of other parameters allowing you to customize the slide behavior:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;floor_normal&lt;/code&gt; - default value: &lt;code&gt;Vector2( 0, 0 )&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This parameter allows you to define what surfaces the engine should consider to be the floor. Setting this lets you use the &lt;code&gt;is_on_floor()&lt;/code&gt;, &lt;code&gt;is_on_wall()&lt;/code&gt;, and &lt;code&gt;is_on_ceiling()&lt;/code&gt; methods to detect what type of surface the body is in contact with. The default value means that all surfaces are considered walls.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;slope_stop_min_velocity&lt;/code&gt; - default value: &lt;code&gt;5&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is the minimum velocity when standing on a slope. This prevents a body from sliding down a slope when standing still.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;max_bounces&lt;/code&gt; - default value: &lt;code&gt;4&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is the maximum number of collisions before the body stops moving. Setting this too low may prevent movement entirely.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;floor_max_angle&lt;/code&gt; - default value: &lt;code&gt;0.785398&lt;/code&gt; (in radians, equivalent to 45 degrees)&lt;/p&gt;

&lt;p&gt;This is the maximum angle before a surface is no longer considered a &amp;ldquo;floor&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;which-to-use&#34;&gt;Which to use?&lt;/h2&gt;

&lt;p&gt;A common question from new Godot users is: &amp;ldquo;How do you decide which movement function to use?&amp;rdquo;
Often the response is to use &lt;code&gt;move_and_slide()&lt;/code&gt; because it&amp;rsquo;s &amp;ldquo;simpler&amp;rdquo;, but this is not
necessarily the case. One way to think of it is that &lt;code&gt;move_and_slide()&lt;/code&gt; is a special case,
and &lt;code&gt;move_and_collide()&lt;/code&gt; is more general. For example, the following two code snippets result in the same collision response:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/k2d_compare.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/k2d_compare.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;collision&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;move_and_collide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;collision&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;slide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;collision&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;normal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;move_and_slide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/p&gt;

&lt;p&gt;Anything you do with &lt;code&gt;move_and_slide()&lt;/code&gt; can also be done with &lt;code&gt;move_and_collide()&lt;/code&gt;,
it just might take a little more code. However, as we&amp;rsquo;ll see in the examples below,
there are cases where &lt;code&gt;move_and_slide()&lt;/code&gt; isn&amp;rsquo;t the response you want.&lt;/p&gt;

&lt;h1 id=&#34;examples&#34;&gt;Examples&lt;/h1&gt;

&lt;p&gt;Download the &lt;a href=&#34;/blog/blog/img/KYN3.0_KinematicBody2D.zip&#34;&gt;Sample Project&lt;/a&gt; for the examples
below.&lt;/p&gt;

&lt;h2 id=&#34;basic-movement&#34;&gt;Basic movement&lt;/h2&gt;

&lt;p&gt;If you&amp;rsquo;ve downloaded the sample project, this example is in the &amp;ldquo;BasicMovement.tscn&amp;rdquo; scene.&lt;/p&gt;

&lt;p&gt;For this example, Add a &lt;code&gt;KinematicBody2D&lt;/code&gt; with two children: a &lt;code&gt;Sprite&lt;/code&gt; and a &lt;code&gt;CollisionShape2D&lt;/code&gt;. As with many demos, we&amp;rsquo;ll use the Godot &amp;ldquo;icon.png&amp;rdquo; as the Sprite&amp;rsquo;s texture (drag it from the Filesystem dock to the &amp;ldquo;Texture&amp;rdquo; property of the &lt;code&gt;Sprite&lt;/code&gt;). In the &lt;code&gt;CollisionShape2D&lt;/code&gt;&amp;rsquo;s &amp;ldquo;Shape&amp;rdquo; property, select &amp;ldquo;New RectangleShape2D&amp;rdquo; and size the rectangle to fit over the sprite image.&lt;/p&gt;

&lt;p&gt;Attach a script to the KinematicBody2D and add the following code:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KinematicBody2D&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;250&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;# Detect up/down/left/right keystate and only move when pressed&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;ui_right&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;ui_left&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;ui_down&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;ui_up&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;normalized&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;get_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;move_and_collide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Run this scene and you&amp;rsquo;ll see that &lt;code&gt;move_and_collide()&lt;/code&gt; works as expected, moving
the body along the velocity vector. Now let&amp;rsquo;s see what happens when you add
some obstacles. Add a StaticBody2D with a rectangular collision shape. For visibility,
you can use a sprite, a Polygon2D, or just turn on &amp;ldquo;Visible Collision Shapes&amp;rdquo; from
the &amp;ldquo;Debug&amp;rdquo; menu.&lt;/p&gt;

&lt;p&gt;Run the scene again and try moving into the obstacle. You&amp;rsquo;ll see that the &lt;code&gt;KinematicBody2D&lt;/code&gt;
can&amp;rsquo;t penetrate the obstacle. However, try moving into the obstacle at an angle and
you&amp;rsquo;ll find that the obstacle acts like glue - it feels like the body gets stuck.&lt;/p&gt;

&lt;p&gt;This happens because there is no &lt;em&gt;collision response&lt;/em&gt;. &lt;code&gt;move_and_collide()&lt;/code&gt; just stops
the body&amp;rsquo;s movement when a collision occurs. We need to code whatever response we
want from the collision.&lt;/p&gt;

&lt;p&gt;Try changing the function to &lt;code&gt;move_and_slide(velocity)&lt;/code&gt; and running again. Note that we removed &lt;code&gt;delta&lt;/code&gt; from the velocity calculation.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;move_and_slide()&lt;/code&gt; provides a default collision response of sliding the body along the
collision object. This is useful for a great many game types, and may be all you need
to get the behavior you want.&lt;/p&gt;

&lt;p&gt;Next, we&amp;rsquo;ll look at a few other examples.&lt;/p&gt;

&lt;h2 id=&#34;bouncing-reflecting-and-collision-detection&#34;&gt;Bouncing/reflecting and collision detection&lt;/h2&gt;

&lt;p&gt;What if you don&amp;rsquo;t want a sliding collision response? For this example (&amp;ldquo;BounceandCollide.tscn&amp;rdquo;
in the sample project), we have a character shooting bullets and we want the bullets to
bounce off the walls.&lt;/p&gt;

&lt;p&gt;For this example, we have three scenes: the main scene containing the Player, a Bullet,
and a Wall. The Bullet and Wall are separate scenes so that they can be instanced.&lt;/p&gt;

&lt;p&gt;The Player is controlled by W/S for forward/back and aims using the mouse. Here is
the code for the Player, using &lt;code&gt;move_and_slide()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KinematicBody2D&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PackedScene&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bullet&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;# add these actions in Project Settings -&amp;gt; Input Map&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;backward&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;forward&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_just_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;mouse_click&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shoot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;# &amp;#34;Muzzle&amp;#34; is a Position2D placed at the barrel of the gun&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bullet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Muzzle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;global_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;get_parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;add_child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;get_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_global_mouse_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;global_position&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;# Don&amp;#39;t move if too close to the mouse pointer&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;dir&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;dir&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;angle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;move_and_slide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;And the code for the Bullet:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KinematicBody2D&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;750&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;dir&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pos&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;collision&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;move_and_collide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;collision&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bounce&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;collision&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;normal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;collision&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;collider&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;has_method&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;hit&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;collision&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;collider&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_on_VisibilityNotifier2D_screen_exited&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;queue_free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The action happens in &lt;code&gt;_physics_process()&lt;/code&gt;. After using &lt;code&gt;move_and_collide()&lt;/code&gt; if a
collision occurs, a &lt;code&gt;KinematicCollision2D&lt;/code&gt; object is returned (otherwise, the return
is &lt;code&gt;Nil&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;If there is a returned collision, we use the &lt;code&gt;normal&lt;/code&gt; of the collision to reflect
the bullet&amp;rsquo;s &lt;code&gt;velocity&lt;/code&gt;. &lt;code&gt;bounce()&lt;/code&gt; is a &lt;code&gt;Vector2&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;If the colliding object (&lt;code&gt;collider&lt;/code&gt;) has a &lt;code&gt;hit&lt;/code&gt; method,
we also call it. In the example project, we&amp;rsquo;ve added a flashing color effect to
the Wall to demonstrate this.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/k2d_bullet_bounce.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/k2d_bullet_bounce.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;platforming-with-move-and-slide&#34;&gt;Platforming with move_and_slide&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s try one more example - one that often gets asked about - the 2D platformer. &lt;code&gt;move_and_slide()&lt;/code&gt; is ideal for quickly getting a functional character controller up and running. If you&amp;rsquo;ve downloaded the sample project, you can find this in &amp;ldquo;Platformer.tscn&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;For this example, we&amp;rsquo;ll assume you have a level made of StaticBody2D objects. They can be any shape and size. In the sample project, we&amp;rsquo;re using a TileMap to lay out the level, but for the purposes of this demo, they could just as well be individual static bodies.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re also using the adorable &lt;a href=&#34;https://opengameart.org/content/sunny-land-2d-pixel-art-pack&#34;&gt;&amp;ldquo;Sunny Land&amp;rdquo; art pack by Ansimuz&lt;/a&gt; for the art and character animations.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the code for the player body:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KinematicBody2D&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;run_speed&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;jump_speed&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gravity&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IDLE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RUN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JUMP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;anim&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new_anim&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;change_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IDLE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;change_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new_state&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;match&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;IDLE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;new_anim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;idle&amp;#39;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;RUN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;new_anim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;run&amp;#39;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;JUMP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;new_anim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;jump_up&amp;#39;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;ui_right&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;ui_left&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;jump&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_just_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;ui_select&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;jump&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is_on_floor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;change_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JUMP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;jump_speed&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;right&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;change_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RUN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;run_speed&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;left&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;change_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RUN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;run_speed&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Sprite&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;flip_h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;right&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;left&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RUN&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;change_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IDLE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;get_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new_anim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;anim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;anim&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new_anim&lt;/span&gt;
        &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AnimationPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;anim&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;gravity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JUMP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is_on_floor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;change_state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IDLE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;move_and_slide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;velocity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;600&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;get_tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reload_current_scene&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/k2d_platf_sample.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/k2d_platf_sample.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re using a very rudimentary state machine to handle the transitions between the character&amp;rsquo;s idle, running, and jumping states.&lt;/p&gt;

&lt;p&gt;When using &lt;code&gt;move_and_slide()&lt;/code&gt; the function returns a vector representing the
movement that remained after the slide collision occurred. Setting that value back
to the character&amp;rsquo;s &lt;code&gt;velocity&lt;/code&gt; allows us to smoothly move up and down slopes. Try
removing &lt;code&gt;velocity =&lt;/code&gt; and see what happens if you don&amp;rsquo;t do this.&lt;/p&gt;

&lt;p&gt;Also note that we&amp;rsquo;ve added &lt;code&gt;Vector2(0, -1)&lt;/code&gt; as the floor normal. This is a vector
pointing straight upward. This means that if the character collides with an object
that has this normal, it will be considered a floor.&lt;/p&gt;

&lt;p&gt;Using the floor normal allows us to make jumping work, using &lt;code&gt;is_on_floor()&lt;/code&gt;. This
function will only return &lt;code&gt;true&lt;/code&gt; after a &lt;code&gt;move_and_slide()&lt;/code&gt; collision where the
colliding body&amp;rsquo;s normal is within 45 degrees of the given floor vector (this can
be adjusted by setting &lt;code&gt;floor_max_angle&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;This also allows you to implement other features like wall jumps using &lt;code&gt;is_on_wall()&lt;/code&gt;,
for example.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;This introduction only scratches the surface of what&amp;rsquo;s possible with KinematicBody2D.
As with all Godot nodes, &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_kinematicbody2d.html&#34; target=&#34;_blank&#34;&gt;
the API documentation&lt;/a&gt; is your friend, so reference it frequently until you&amp;rsquo;re
comfortable with the class methods.&lt;/p&gt;

&lt;p&gt;Kinematic bodies are so useful, that I&amp;rsquo;ll probably do a followup &amp;ldquo;Know Your Nodes&amp;rdquo; exploring
more uses. Please comment below if you have ideas or suggestions for other examples you&amp;rsquo;d
like to see.&lt;/p&gt;

&lt;h3 id=&#34;a-href-blog-img-kyn3-0-kinematicbody2d-zip-download-the-sample-project-a&#34;&gt;&lt;a href=&#34;/blog/blog/img/KYN3.0_KinematicBody2D.zip&#34;&gt;Download the sample project&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godotengine.org/download&#34;&gt;Download Godot 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Me on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Godot 3.0: Inheritance</title>
      <link>/blog/2018/01/godot3_inheritance/</link>
      <pubDate>Fri, 19 Jan 2018 15:12:12 -0700</pubDate>
      
      <guid>/blog/2018/01/godot3_inheritance/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/blog/blog/img/godot_logo.png&#34; width=&#34;450&#34;&gt;&lt;/p&gt;

&lt;p&gt;In this tutorial, we&amp;rsquo;ll explore how inheritance works in Godot. You can use
inheritance in Godot to reuse code and create powerful hierarchies of object and
scenes in your game.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll imagine we&amp;rsquo;re making a classic top-down RPG and use Godot&amp;rsquo;s inheritance
capabilities to create two different kinds of characters in the game.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/Z0w9Jviq57c&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;In object oriented programming (OOP), &lt;em&gt;inheritance&lt;/em&gt; is a powerful tool. Put briefly, you can
define a class that &lt;em&gt;inherits&lt;/em&gt; from another class. An object created using the first class will
contain the methods and member variables of the &amp;ldquo;master&amp;rdquo; class as well as its own.&lt;/p&gt;

&lt;p&gt;Godot is strongly object-oriented, and offers the opportunity to use inheritance
not just with objects (scripts) but also with scenes.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a preview of what we&amp;rsquo;re making:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/inh_preview.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/inh_preview.gif&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;The green character is controlled by the player, and the other characters are NPCs,
walking around the tile-based map semi-randomly.&lt;/p&gt;

&lt;h2 id=&#34;project-setup&#34;&gt;Project setup&lt;/h2&gt;

&lt;p&gt;In &lt;em&gt;Project Settings&lt;/em&gt; create four new input actions called &amp;ldquo;left&amp;rdquo;, &amp;ldquo;right&amp;rdquo;, &amp;ldquo;up&amp;rdquo;, and &amp;ldquo;down&amp;rdquo; and assign
each of them to the matching arrow key. We&amp;rsquo;ll be using those names as dictionary keys, so make sure to
note the spelling and capitalization.&lt;/p&gt;

&lt;p&gt;Set the display &lt;em&gt;Width&lt;/em&gt; and &lt;em&gt;Height&lt;/em&gt; to &lt;code&gt;640&lt;/code&gt; by &lt;code&gt;480&lt;/code&gt; (we&amp;rsquo;re using 32x32 tiles, so we don&amp;rsquo;t need much
screen space for this demo).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/inheritance_art.zip&#34;&gt;Download the art&lt;/a&gt; (character spritesheets) and unzip it in the project folder.&lt;/p&gt;

&lt;h2 id=&#34;creating-characters&#34;&gt;Creating Characters&lt;/h2&gt;

&lt;p&gt;Both kinds of characters share a number of properties and functions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A spritesheet containing the 4-directional movement animations&lt;/li&gt;
&lt;li&gt;An AnimationPlayer to play the movement animations&lt;/li&gt;
&lt;li&gt;Grid-based movement (the character can only move one full &amp;ldquo;square&amp;rdquo; at a time)&lt;/li&gt;
&lt;li&gt;Collision detection with walls&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ll start by creating a scene that will contain all of the above. Start with an
&lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_area2d.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Area2D&lt;/code&gt;&lt;/a&gt;
and name it &amp;ldquo;Character&amp;rdquo;. Give it the following children:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_sprite.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Sprite&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_collisionshape2d.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;CollisionShape2D&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_tween.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Tween&lt;/code&gt;&lt;/a&gt; (named &lt;code&gt;MoveTween&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_animationplayer.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;AnimationPlayer&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We&amp;rsquo;ll leave the &lt;code&gt;Sprite&lt;/code&gt; without a texture for now, but in the Inspector set its &lt;em&gt;Vframes&lt;/em&gt; and &lt;em&gt;Hframes&lt;/em&gt; properties
to &lt;code&gt;4&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt; respectively.&lt;/p&gt;

&lt;p&gt;Next, create a &lt;code&gt;RectangleShape2D&lt;/code&gt; in the collision shape and set its &lt;em&gt;Extents&lt;/em&gt; property in the Inspector to &lt;code&gt;(10, 18)&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; Because all the characters are drawn to the same scale, we can be confident that the same sized collision
shape will work for all characters. If this isn&amp;rsquo;t the case with the art you&amp;rsquo;re using, you can skip setting the collision
shape here and configure it later for the inherited scenes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;animations&#34;&gt;Animations&lt;/h3&gt;

&lt;p&gt;Create four animations in the &lt;code&gt;AnimationPlayer&lt;/code&gt; node. Name them to match the four directions we used in the input
actions. For each animation, we&amp;rsquo;re going to set the length to &lt;code&gt;0.8&lt;/code&gt; and add a track for the &lt;code&gt;Sprite&lt;/code&gt;&amp;rsquo;s &lt;em&gt;Frame&lt;/em&gt; property.
The pattern for each direction is listed below. See the screenshot for an example of the end result.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;direction&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;frames&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;left&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;9, 10, 11, 10&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;down&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;6, 7, 8, 7&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;right&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;3, 4, 5, 4&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;up&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;0, 1, 2, 1&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/inh_animation_frames.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/inh_animation_frames.png&#34; width=&#34;400&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;h3 id=&#34;collision-detection&#34;&gt;Collision Detection&lt;/h3&gt;

&lt;p&gt;Because the characters are moving on a grid, they will either move the full amount to the next tile or not at all.
This means that before moving, the character needs to check if the move is possible. Add four &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_raycast2d.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;RayCast2D&lt;/code&gt;&lt;/a&gt; nodes and
set their names and &lt;em&gt;Cast To&lt;/em&gt; properties as follows:&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Name&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;&lt;em&gt;Cast To&lt;/em&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RayCastRight&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;(32, 0)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RayCastLeft&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;(-32, 0)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RayCastDown&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;(0, 32)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;RayCastUp&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;&lt;code&gt;(0, -32)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Make sure to set the &lt;em&gt;Enabled&lt;/em&gt; property on each one (RayCast2Ds are disabled by default).
Your final node setup should look something like this:
&lt;img src=&#34;/blog/blog/img/inh_scene_char.png&#34; width=&#34;200&#34;&gt;&lt;/p&gt;

&lt;h3 id=&#34;character-script&#34;&gt;Character Script&lt;/h3&gt;

&lt;p&gt;Now add a script to the &lt;code&gt;Character&lt;/code&gt; node (it will automatically be named &amp;ldquo;Character.gd&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;First, we&amp;rsquo;ll define our class variables:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Area2D&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tile_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;can_move&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;facing&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;right&amp;#39;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;moves&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;right&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
             &lt;span class=&#34;s1&#34;&gt;&amp;#39;left&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
             &lt;span class=&#34;s1&#34;&gt;&amp;#39;up&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
             &lt;span class=&#34;s1&#34;&gt;&amp;#39;down&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)}&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;raycasts&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;right&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;RayCastRight&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s1&#34;&gt;&amp;#39;left&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;RayCastLeft&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s1&#34;&gt;&amp;#39;up&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;RayCastUp&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s1&#34;&gt;&amp;#39;down&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;RayCastDown&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
 &lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;can_move&lt;/code&gt; is a flag that will track whether the character can move. It will be &lt;code&gt;false&lt;/code&gt;
while a movement is already underway. &lt;code&gt;facing&lt;/code&gt; is the current direction of movement.
Note that the &lt;code&gt;moves&lt;/code&gt; and &lt;code&gt;raycasts&lt;/code&gt; dictionaries&amp;rsquo; keys match the input actions we created.&lt;/p&gt;

&lt;p&gt;Next is the code that will execute a movement from one square to another:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;raycasts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;facing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_colliding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;facing&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;dir&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;can_move&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;false&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AnimationPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;facing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MoveTween&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;interpolate_property&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;bp&#34;&gt;self&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;position&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                      &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;moves&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;facing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tile_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                      &lt;span class=&#34;n&#34;&gt;Tween&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TRANS_SINE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Tween&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;EASE_IN_OUT&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MoveTween&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We pass a direction to &lt;code&gt;move()&lt;/code&gt;. If the RayCast2D for that direction detects a collision, the move
is canceled. Otherwise, we change &lt;code&gt;facing&lt;/code&gt; to that direction, disable movement, and start playing
the matching animation. To actually execute the movement, we use the &lt;code&gt;Tween&lt;/code&gt; node to interpolate
the &lt;code&gt;position&lt;/code&gt; property from its current value to its current value plus a 32-pixel movement in
the given direction. The duration is set to &lt;code&gt;0.8&lt;/code&gt; which matches the animation length.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; See the &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_tween.html&#34; target=&#34;_blank&#34;&gt;Tween
documentation&lt;/a&gt; for details on how the &lt;code&gt;interpolate_property()&lt;/code&gt; method works.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Finally, to enable movement again, we need to reset &lt;code&gt;can_move&lt;/code&gt; when the movement has finished. Connect
the &lt;code&gt;tween_completed&lt;/code&gt; signal from &lt;code&gt;MoveTween&lt;/code&gt; and add the following:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_on_MoveTween_tween_completed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;can_move&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;implementing-the-player&#34;&gt;Implementing the Player&lt;/h2&gt;

&lt;p&gt;The player character needs to inherit all the properties we gave to &lt;code&gt;Character&lt;/code&gt; as well as
adding keyboard controlled movement.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll start by making a new scene. However, instead of making a new empty scene,
click on &lt;em&gt;Scene -&amp;gt; New Inherited Scene&lt;/em&gt; in the menu. Select the &lt;code&gt;Character.tscn&lt;/code&gt;.
Rename the root node from &amp;ldquo;Character&amp;rdquo; to &amp;ldquo;Player&amp;rdquo; and save the new scene.&lt;/p&gt;

&lt;p&gt;All we need to do for the &lt;code&gt;Sprite&lt;/code&gt; is set the texture, so choose a character you like from the &amp;ldquo;res://art/rpgsprites1&amp;rdquo;
folder and drag it to the &lt;em&gt;Texture&lt;/em&gt; property.&lt;/p&gt;

&lt;p&gt;Next, we need a new script for the player, so remove the attached one (&amp;ldquo;Character.gd&amp;rdquo;) and
attach a new one. In the &amp;ldquo;Attach Node Script&amp;rdquo; dialog, click the folder icon next to the &lt;em&gt;Inherits&lt;/em&gt; option
and choose &amp;ldquo;Character.gd&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/inh_script.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/inh_script.png&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s our player script (note that it &lt;code&gt;extends&lt;/code&gt; the character script):&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;res://Character.gd&amp;#34;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;can_move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;dir&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;moves&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
                &lt;span class=&#34;n&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Because we&amp;rsquo;ve inherited all the behavior from &amp;ldquo;Character.gd&amp;rdquo;, we only need to worry about control. Here, we&amp;rsquo;re
using the &lt;code&gt;_process()&lt;/code&gt; function to check the keystate each frame. However, only if &lt;code&gt;can_move&lt;/code&gt; allows it do we
actually check the keys and call &lt;code&gt;move()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Run the scene and try it out.&lt;/p&gt;

&lt;h2 id=&#34;npc-characters&#34;&gt;NPC characters&lt;/h2&gt;

&lt;p&gt;Hopefully you&amp;rsquo;re seeing how inheritance works by now, but let&amp;rsquo;s make another type of character: an NPC that
will wander around the screen randomly. Make another scene inheriting from &amp;ldquo;Character.tscn&amp;rdquo; and name it NPC.&lt;/p&gt;

&lt;p&gt;This time, leave the sprite&amp;rsquo;s &lt;em&gt;Texture&lt;/em&gt; blank and add a new script, again inheriting from &amp;ldquo;Character.gd&amp;rdquo;.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;res://Character.gd&amp;#34;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;textures&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;mage_f.png&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;mage_m.png&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s1&#34;&gt;&amp;#39;healer_f.png&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;healer_m.png&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s1&#34;&gt;&amp;#39;townfolk1_f.png&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;townfolk1_m.png&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;randomize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;textures&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;randi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;textures&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()]&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;res://art/rpgsprites1/&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%s&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Sprite&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;facing&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;moves&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;randi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;can_move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;facing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;or&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;randi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;facing&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;moves&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;randi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This time, we&amp;rsquo;re using &lt;code&gt;_ready()&lt;/code&gt; to select a random texture and assign it. We&amp;rsquo;re also choosing a
random starting direction.&lt;/p&gt;

&lt;p&gt;As with the player, we&amp;rsquo;ll use &lt;code&gt;_process()&lt;/code&gt; to trigger the movement, but this time we&amp;rsquo;ll use the
fact that the &lt;code&gt;move()&lt;/code&gt; function returns &lt;code&gt;true&lt;/code&gt; if it successfully executes (if the raycast detects
an obstacle, it returns &lt;code&gt;false&lt;/code&gt;). So if the NPC can&amp;rsquo;t move, it will pick a new random direction.
For variety, we also add a 50% chance that it will change direction anyway.&lt;/p&gt;

&lt;p&gt;Run the scene and observe the NPC wandering randomly around the screen.&lt;/p&gt;

&lt;h2 id=&#34;testing-collisions&#34;&gt;Testing Collisions&lt;/h2&gt;

&lt;p&gt;Finally, to confirm that the collision detection is working, let&amp;rsquo;s create a small scene for the
characters to wander around in. We&amp;rsquo;ll use a &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_tilemap.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;TileMap&lt;/code&gt;&lt;/a&gt; to quickly draw our map.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; See my &lt;a href=&#34;https://youtu.be/LBK5GgMB988&#34; target=&#34;_blank&#34;&gt;Tilemap tutorial&lt;/a&gt; for details on using
TileMaps in Godot.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;There are two tiles (&amp;ldquo;grass.png&amp;rdquo; and &amp;ldquo;stone.png&amp;rdquo;) in the art folder. There is also a &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_tileset.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;TileSet&lt;/code&gt;&lt;/a&gt; called
&amp;ldquo;tiles.tres&amp;rdquo; to save you the step of making your own. In it, only the stone tile has a collision shape, so it
will be our obstacle.&lt;/p&gt;

&lt;p&gt;Create a new &amp;ldquo;Main&amp;rdquo; scene (I usually like to use a plain &lt;code&gt;Node&lt;/code&gt; as the root). Add a &lt;code&gt;TileMap&lt;/code&gt; and drag &amp;ldquo;tileset.tres&amp;rdquo;
into its &lt;em&gt;Tile Set&lt;/em&gt; property. Also don&amp;rsquo;t forget to change the &lt;em&gt;Size&lt;/em&gt; to &lt;code&gt;(32, 32)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Draw some walls as you like, and then add a &lt;code&gt;Player&lt;/code&gt; instance and a few instances of &lt;code&gt;NPC&lt;/code&gt;. Remember, the characters
won&amp;rsquo;t know anything about the map - they just know if they can move one tile or not. If you want them to line up properly,
you need to make sure the characters&amp;rsquo; starting positions are centered on a tile. This is easy to do if you turn
on &amp;ldquo;Snap to Grid&amp;rdquo;. Click the &amp;ldquo;Use Snap&amp;rdquo; button and then open the grid menu by clicking on the three dots next to it:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/inh_snap2.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/inh_snap2.png&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Under &amp;ldquo;Configure Snap&amp;hellip;&amp;rdquo; set the &lt;em&gt;Grid Step&lt;/em&gt; and &lt;em&gt;Grid Offset&lt;/em&gt;:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/inh_snap.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/inh_snap.png&#34; width=&#34;300&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now you can drag the instanced characters around and they&amp;rsquo;ll always snap to the center of a tile.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Imagine we had built this project without using inheritance. The Player and NPC would each have their own scene
setup and individual scripts. If we decided to change how we wanted movement to work, we would have to change
everything twice. If we added more character types (Monsters, Pets, etc.) the duplicated code would
multiply and quickly become unmanageable. With the setup we created above, everything is in one place, and any
change to the character automatically propagates to everything that extends it.&lt;/p&gt;

&lt;p&gt;As you&amp;rsquo;re working on your own projects, look for opportunities to consolidate code and use inheritance for
your scenes and/or scripts. As your projects grow in size and complexity, it will quickly become a lifesaver.&lt;/p&gt;

&lt;h3 id=&#34;a-href-blog-img-inheritance-demo-zip-download-the-full-project-a&#34;&gt;&lt;a href=&#34;/blog/blog/img/Inheritance_Demo.zip&#34;&gt;Download the full project&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godotengine.org/download&#34;&gt;Download Godot 3.0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Me on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Godot 3.0: Rigid Bodies</title>
      <link>/blog/2017/12/godot3_kyn_rigidbody1/</link>
      <pubDate>Sat, 30 Dec 2017 08:12:12 -0700</pubDate>
      
      <guid>/blog/2017/12/godot3_kyn_rigidbody1/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/blog/blog/img/godot_logo.png&#34; width=&#34;450&#34;&gt;&lt;/p&gt;

&lt;p&gt;At the time of this writing, Godot 3.0 is nearing release, and many new users are
trying it out. Recently I&amp;rsquo;ve seen a lot of confusion around physics and physics
bodies, especially rigid bodies, which are Godot&amp;rsquo;s &amp;ldquo;true&amp;rdquo; physics nodes.&lt;/p&gt;

&lt;p&gt;In this tutorial, I&amp;rsquo;ll explain when (and when not) to use rigid bodies, how they
work, and demonstrate a few handy tricks to bend them to your will. The
examples will use RigidBody2D, but the lessons apply equally to 3D.&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/xsAyx2r1bQU&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_rigidbody2d.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_rigid_body_2d&#34;&gt;
&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_rigid_body_2d&#34;&gt;&lt;/svg&gt; &lt;code&gt;RigidBody2D&lt;/code&gt;&lt;/a&gt;
is the physics body in Godot that provides simulated physics. This means that you
don&amp;rsquo;t control a RigidBody2D directly. Instead you apply forces to it (gravity, impulses,
etc.) and Godot&amp;rsquo;s built-in physics engine calculates the resulting movement, including
collisions, bouncing, rotating, etc.&lt;/p&gt;

&lt;p&gt;You can modify a RigidBody2D&amp;rsquo;s behavior via properties such as &amp;ldquo;Mass&amp;rdquo;, &amp;ldquo;Friction&amp;rdquo;,
or &amp;ldquo;Bounce&amp;rdquo;, which can be set in the Inspector:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/rigidbody_properties.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/rigidbody_properties.png&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The body&amp;rsquo;s behavior is also affected by the world, via the &lt;em&gt;Project Settings -&amp;gt; Physics&lt;/em&gt;
properties, or by entering an &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_area2d.html&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_area_2d&#34; target=&#34;_blank&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_area_2d&#34;&gt;&lt;/svg&gt; &lt;code&gt;Area2D&lt;/code&gt;&lt;/a&gt; that is overriding the global physics properties.&lt;/p&gt;

&lt;h2 id=&#34;using-rigidbody2d&#34;&gt;Using RigidBody2D&lt;/h2&gt;

&lt;p&gt;One of the benefits of using a rigid body is that a lot of behavior can be gotten &amp;ldquo;for
free&amp;rdquo; without writing any code. For example, let&amp;rsquo;s look at making a rudimentary
&amp;ldquo;Angry Birds&amp;rdquo;-style game with falling blocks. You only need to create RigidBody2Ds
for the blocks and projectile, and set their properties. Stacking, falling, and bouncing
will automatically be handled by the physics engine.&lt;/p&gt;

&lt;h3 id=&#34;stacking-blocks&#34;&gt;Stacking blocks&lt;/h3&gt;

&lt;p&gt;Start by making a RigidBody2D for the block and adding &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_sprite.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_sprite&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_sprite&#34;&gt;&lt;/svg&gt;&lt;code&gt;Sprite&lt;/code&gt;&lt;/a&gt; and
&lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_collisionshape2D.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_collision_shape_2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_collision_shape_2d&#34;&gt;&lt;/svg&gt;&lt;code&gt;CollisionShape2D&lt;/code&gt;&lt;/a&gt;
children:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/rigidbody_block_scene.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/rigidbody_block_scene.png&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Add a texture to the Sprite and a rectangular collision shape. &lt;strong&gt;IMPORTANT&lt;/strong&gt;: Do &lt;em&gt;not&lt;/em&gt;
change the &lt;em&gt;Scale&lt;/em&gt; of the collision shape! In general this is a bad idea, and will
result in unexpected collision behavior. Always use the shape&amp;rsquo;s inner size handles and
not the outer &lt;code&gt;Node2D&lt;/code&gt;-derived scale handles.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; For the textures in this example, I&amp;rsquo;m using the &lt;a href=&#34;http://kenney.nl/assets/physics-assets&#34;&gt;Physics Asset&lt;/a&gt; pack from Kenney.nl. It contains a
wide variety of blocks in different shapes and materials.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Press &amp;ldquo;Play&amp;rdquo; and you&amp;rsquo;ll see the block fall slowly downward. This is due to the
default global gravity. You can find this setting in &amp;ldquo;Project Settings&amp;rdquo; under
&lt;em&gt;Physics -&amp;gt; 2d&lt;/em&gt;. You can also try changing the Block&amp;rsquo;s &lt;code&gt;Gravity Scale&lt;/code&gt; property in the
Inspector. I&amp;rsquo;m using a value of &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now create a Main scene (I usually use a &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_node.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_node&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_node&#34;&gt;&lt;/svg&gt;Node&lt;/a&gt;) for the root).
Add a few &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_staticbody2d.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_staticbody2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_static_body_2d&#34;&gt;&lt;/svg&gt;StaticBody2D&lt;/a&gt;
nodes with rectangular collision shapes to serve as your &amp;ldquo;ground&amp;rdquo; and walls.&lt;/p&gt;

&lt;p&gt;Instance a Block, and then duplicate it (&lt;code&gt;Ctrl-D&lt;/code&gt; on Windows and &lt;code&gt;Cmd-D&lt;/code&gt; on MacOS)
so you can make a nice stack. Something like this:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/rigidbody_scene1.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/rigidbody_scene1.png&#34; width=&#34;350&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;projectile&#34;&gt;Projectile&lt;/h3&gt;

&lt;p&gt;Create another scene with the same node setup as your Block, but name this one &amp;ldquo;Ball&amp;rdquo;. Use one of
the round textures and a circular collision shape. Instance this in your Main
scene and place it somewhere to the side of the stack of blocks.&lt;/p&gt;

&lt;p&gt;To cause a rigid body to move, it must have some velocity. You can give the body
an initial velocity using the &lt;code&gt;Linear -&amp;gt; Velocity&lt;/code&gt; property. Try setting this
to &lt;code&gt;(500, 0)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/rigidbody_vel.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/rigidbody_vel.gif&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You can also tinker with the ball&amp;rsquo;s &lt;code&gt;Friction&lt;/code&gt; and &lt;code&gt;Bounce&lt;/code&gt; properties. Both of
these properties can range from zero to one. I like a bounce of around &lt;code&gt;0.5&lt;/code&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;IMPORTANT:&lt;/strong&gt; &lt;em&gt;NEVER&lt;/em&gt; scale a physics body! If you try, a warning will appear,
and when the scene runs, the physics engine will automatically set the scale back
to &lt;code&gt;(1, 1)&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;forces&#34;&gt;Forces&lt;/h3&gt;

&lt;p&gt;Reset the linear velocity to &lt;code&gt;(0, 0)&lt;/code&gt;. Now what if you want to be able to toss
the ball? You should never set a rigid body&amp;rsquo;s velocity or position manually -
remember, these are simulating &amp;ldquo;real-world&amp;rdquo; style physics. In the real world,
objects can&amp;rsquo;t instantly jump from place to place or from a standstill to a high
speed. If you try and do so, the physics engine will resist it, and unexpected
movement can occur. Instead, we must apply forces which create an acceleration in a certain
direction (also known as Newton&amp;rsquo;s Second Law). Godot physics objects work in
the same way.&lt;/p&gt;

&lt;p&gt;To add force to a rigid body, you have two functions to choose from:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;add_force()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Adds a continuous force to the body. Imagine a rocket&amp;rsquo;s thrust, steadily
pushing it faster and faster. Note that this &lt;em&gt;adds&lt;/em&gt; to any already existing
forces. The force continues to be applied until removed.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;apply_impulse()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Adds an instantaneous &amp;ldquo;kick&amp;rdquo; to the body. Imagine hitting a baseball with a bat.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use &lt;code&gt;apply_impulse()&lt;/code&gt; to kick the ball when we click, drag, and release
the mouse button.&lt;/p&gt;

&lt;p&gt;Open &amp;ldquo;Project Settings&amp;rdquo; and in the &amp;ldquo;Input Map&amp;rdquo; tab, add a new action called &amp;ldquo;click&amp;rdquo;.
Connect it to the left mouse button.&lt;/p&gt;

&lt;p&gt;Next, add a script to the Ball, and add the following code:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RigidBody2D&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;dragging&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;drag_start&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dragging&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;dragging&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;drag_start&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_global_mouse_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;event&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_released&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;click&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dragging&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;dragging&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
		&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;drag_end&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_global_mouse_position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;dir&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;drag_start&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;drag_end&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;apply_impulse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This script toggles &lt;code&gt;dragging&lt;/code&gt; on when the mouse button is pressed and records
the location of the click. When the button is released, we find the vector from
the click point to the release point and use that to apply the impulse (multiplying
by &lt;code&gt;5&lt;/code&gt; to scale it up). &lt;code&gt;apply_impulse()&lt;/code&gt; also takes an &lt;code&gt;offset&lt;/code&gt; as its first
parameter. This lets you &amp;ldquo;hit&amp;rdquo; the body off center, if you wish. For instance,
try setting it to &lt;code&gt;Vector2(25, 0)&lt;/code&gt; and you&amp;rsquo;ll add some spin to the ball when
it&amp;rsquo;s launched.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/rigidbody_impulse.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/rigidbody_impulse.gif&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;controlling-rigid-bodies&#34;&gt;Controlling Rigid Bodies&lt;/h2&gt;

&lt;p&gt;There are cases where you need more direct control of a rigid body. For example,
imagine you&amp;rsquo;re trying to make a version of the classic game &amp;ldquo;Asteroids&amp;rdquo;. The
player&amp;rsquo;s spaceship needs to rotate using the left/right arrow keys, and to move
forward when the up arrow is pressed.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the image I&amp;rsquo;m using for my ship:
&lt;a href=&#34;/blog/blog/img/ship_red.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/ship_red.png&#34; width=&#34;124&#34;&gt;&lt;/a&gt;
I recommend you also go to &lt;a href=&#34;http://opengameart.org/&#34;&gt;OpenGameArt&lt;/a&gt; and search for
a nice space background (but this is totally optional).&lt;/p&gt;

&lt;p&gt;Create a new scene for the ship as we did above with the following node structure:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;RigidBody2D&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Sprite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CollisionShape2D&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; In Godot 3.0, &lt;code&gt;0&lt;/code&gt; degrees points to the left (along the &lt;strong&gt;x&lt;/strong&gt; axis).
This means you need to add a &lt;code&gt;Rotation&lt;/code&gt; of &lt;code&gt;90&lt;/code&gt; to the &lt;code&gt;Sprite&lt;/code&gt; so it will
match the body&amp;rsquo;s direction.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;By default, the physics settings provide some &lt;em&gt;damping&lt;/em&gt;, which reduces a body&amp;rsquo;s
velocity and spin. In space, there&amp;rsquo;s no friction, so there shouldn&amp;rsquo;t be any
damping at all. However, for the &amp;ldquo;Asteroids&amp;rdquo; feel, we want the ship to stop rotating
when we let go of the keys, so set the ship&amp;rsquo;s &lt;code&gt;Angular -&amp;gt; Damp&lt;/code&gt; to &lt;code&gt;5&lt;/code&gt;.&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RigidBody2D&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;engine_thrust&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;spin_thrust&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;thrust&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;rotation_dir&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;screensize&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;screensize&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_viewport&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_visible_rect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ui_up&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;thrust&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;engine_thrust&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;thrust&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;rotation_dir&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ui_right&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;rotation_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;is_action_pressed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ui_left&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;rotation_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
		
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;get_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;set_applied_force&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thrust&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;set_applied_torque&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spin_thrust&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Let&amp;rsquo;s walk through what this script is doing. The two variables, &lt;code&gt;engine_thrust&lt;/code&gt;
and &lt;code&gt;spin_thrust&lt;/code&gt; control how fast the ship can accelerate and turn. In the
Inspector, set them to &lt;code&gt;500&lt;/code&gt; and &lt;code&gt;25000&lt;/code&gt; respectively (the units of torque make
for large numbers). &lt;code&gt;thrust&lt;/code&gt; will represent the ship&amp;rsquo;s engine state: &lt;code&gt;(0, 0)&lt;/code&gt;
when coasting, or a vector with the length of &lt;code&gt;engine_thrust&lt;/code&gt; when powered on.
&lt;code&gt;rotation_dir&lt;/code&gt; will represent what direction the ship is turning. The &lt;code&gt;screensize&lt;/code&gt;
variable will capture the size of the screen, which we&amp;rsquo;ll be using later.&lt;/p&gt;

&lt;p&gt;Next, the &lt;code&gt;input()&lt;/code&gt; function captures the keystates and sets the ship&amp;rsquo;s &lt;code&gt;thrust&lt;/code&gt;
on or off, and the rotation direction (&lt;code&gt;rotation_dir&lt;/code&gt;) positive or negative. This
function is called every frame in &lt;code&gt;_process()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Finally, physics-related functions should be called in &lt;code&gt;_physics_process()&lt;/code&gt;. Here
we use &lt;code&gt;set_applied_force()&lt;/code&gt; to apply the &lt;code&gt;thrust&lt;/code&gt; in whatever &lt;code&gt;direction&lt;/code&gt; the
ship is facing. Then we use &lt;code&gt;set_applied_torque()&lt;/code&gt; to cause the ship to rotate.&lt;/p&gt;

&lt;p&gt;Play the scene - you should be able to fly around freely.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/rigidbody_ship1.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/rigidbody_ship1.gif&#34; width=&#34;350&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;the-position-problem&#34;&gt;The Position Problem&lt;/h2&gt;

&lt;p&gt;Another feature of &amp;ldquo;Asteroids&amp;rdquo; is that the screen &amp;ldquo;wraps around&amp;rdquo;. If the player
goes off one side, it teleports to the other side. But we already talked above
about how you can&amp;rsquo;t change a rigid body&amp;rsquo;s position without breaking the physics
engine. This presents a huge problem when working with rigid bodies.&lt;/p&gt;

&lt;p&gt;A common mistake is to try adding something like this to &lt;code&gt;_physics_process()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_physics_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screensize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screensize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screensize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;position&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screensize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;set_applied_force&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thrust&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;set_applied_torque&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spin_thrust&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This fails spectacularly, trapping the player on the edge of the screen (with
occasional glitches). So why doesn&amp;rsquo;t this work? The docs say &lt;code&gt;_physics_process()&lt;/code&gt;
is for physics-related stuff, right?&lt;/p&gt;

&lt;p&gt;Not exactly. &lt;code&gt;_physics_process()&lt;/code&gt; is &lt;em&gt;synced&lt;/em&gt; to the physics timestep, but that
doesn&amp;rsquo;t make it OK to use for just anything. Hope is not lost, however, the answer
is in the docs.&lt;/p&gt;

&lt;p&gt;To quote the &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_rigidbody2d.html#description&#34;&gt;RigidBody2D docs&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;You should not change a RigidBody2Ds position or linear_velocity every frame or even very often. If you need to directly affect the bodys state, use &lt;code&gt;_integrate_forces&lt;/code&gt;, which allows you to directly access the physics state.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And the &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_rigidbody2d.html#class-rigidbody2d-integrate-forces&#34;&gt;description for _integrate_forces&lt;/a&gt;:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Allows you to read and &lt;strong&gt;safely modify&lt;/strong&gt; the simulation state for the object. Use this instead of &lt;code&gt;_physics_process&lt;/code&gt; if you need to directly change the bodys position or other physics properties.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So there&amp;rsquo;s our answer. Instead of using &lt;code&gt;_physics_process()&lt;/code&gt; we need to use &lt;code&gt;_integrate_forces()&lt;/code&gt;,
which gives us access to the &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_physics2ddirectbodystate.html&#34; target=&#34;_blank&#34;&gt;Physics2DDirectBodyState&lt;/a&gt;. I highly recommend you take a look at the
linked document, there is a lot of really useful data provided in the physics state object.
For our purposes, the key piece of information is the body&amp;rsquo;s &lt;a href=&#34;http://docs.godotengine.org/en/latest/classes/class_transform2d.html&#34; target=&#34;_blank&#34;&gt;Transform2D&lt;/a&gt;.
(Explaining transforms is beyond the scope of this document - see &lt;a href=&#34;http://docs.godotengine.org/en/latest/learning/features/math/matrices_and_transforms.html&#34;&gt;Matrices and transforms&lt;/a&gt;
for more information.)&lt;/p&gt;

&lt;p&gt;The body&amp;rsquo;s position is contained in the transform&amp;rsquo;s &lt;code&gt;origin&lt;/code&gt;. Change &lt;code&gt;_physics_process()&lt;/code&gt;
to &lt;code&gt;_integrate_forces()&lt;/code&gt; and add the following code:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-swift&#34; data-lang=&#34;swift&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;_integrate_forces&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;set_applied_force&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;thrust&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotated&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;set_applied_torque&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;rotation_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;spin_thrust&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;xform&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_transform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;origin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screensize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;xform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;origin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;origin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;xform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;origin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screensize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;origin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screensize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;xform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;origin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;xform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;origin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;xform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;origin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;screensize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;set_transform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xform&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We grab the current transform, change it as necessary, and set it back as the new
transform. The physics engine stays happy, and everything works as expected:
&lt;a href=&#34;/blog/blog/img/rigidbody_ship2.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/rigidbody_ship2.gif&#34; width=&#34;350&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;When used properly, rigid bodies are a powerful tool in your Godot toolkit. Many
users get in trouble, however, when they use them for the wrong purposes, or
fail to understand exactly how they work.&lt;/p&gt;

&lt;p&gt;I hope you found this (fairly long) lesson useful. As Godot 3.0 nears release,
I&amp;rsquo;ll be putting out more &amp;ldquo;Know Your Nodes&amp;rdquo; and other 3.0-related content. Good
luck, and happy game making!&lt;/p&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://godotengine.org/article/dev-snapshot-godot-3-0-beta-2&#34;&gt;Download Godot 3.0 Beta 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Me on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Godot Engine in the Classroom: Getting Started</title>
      <link>/blog/2017/11/godot_classroom_1/</link>
      <pubDate>Fri, 10 Nov 2017 08:22:12 -0700</pubDate>
      
      <guid>/blog/2017/11/godot_classroom_1/</guid>
      <description>&lt;p&gt;I began using Godot Engine with a group of students. This is a small group of
my most advanced middle schoolers (ages 11-12), with 1+ years of Python
experience. I do an &amp;ldquo;advanced topics&amp;rdquo; class with them every Thursday after school.
They have never used a game engine before.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s how it went.&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;h2 id=&#34;introduction&#34;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Part of the reason for doing this was to get some real-world experience taking
students through the &lt;a href=&#34;http://docs.godotengine.org/en/latest/learning/step_by_step/your_first_game.html&#34;&gt;
&amp;ldquo;Dodge the Creeps&amp;rdquo;&lt;/a&gt; tutorial I wrote for the Godot 3.0
documentation. This is designed to be a user&amp;rsquo;s first experience making a project
in Godot, and I wanted to see first-hand where any pain points might be.&lt;/p&gt;

&lt;p&gt;This means we are using the Godot 3.0 alpha. It&amp;rsquo;s very stable at this point,
so I feel fairly confident that students won&amp;rsquo;t run into any showstopping bugs
along the way. Fortunately, these kids are happy to be guinea pigs.&lt;/p&gt;

&lt;h2 id=&#34;first-steps&#34;&gt;First steps&lt;/h2&gt;

&lt;p&gt;We started with an introduction to the engine UI and an overview of the concept
of scenes and nodes - the fundamental building blocks of Godot. Since they are
very familiar with Python&amp;rsquo;s object model, they were able to relate the ideas of
a Godot node and a Python object.&lt;/p&gt;

&lt;p&gt;Most of the students have at heard of Unity, so there was some discussion of what
a game engine is, closed- versus open-source, and why a developer might choose
one option over another.&lt;/p&gt;

&lt;p&gt;Two of the students either didn&amp;rsquo;t hear or were too excited, and didn&amp;rsquo;t click
&amp;ldquo;Create folder&amp;rdquo; when making the new project. That means the project was created
in their home folder. Fortunately, that wasn&amp;rsquo;t too tough to correct, but I&amp;rsquo;m
going to suggest a feature that warns when creating a new project in an non-empty
folder.&lt;/p&gt;

&lt;p&gt;As always with students, file management (moving the art assets into the project
folder) was more painful and frustrating than any of the coding ever is.&lt;/p&gt;

&lt;p&gt;Some first reactions:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Whoa, this looks complicated!&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Cool! It&amp;rsquo;s all black!&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;creating-the-player&#34;&gt;Creating the player&lt;/h2&gt;

&lt;p&gt;The first part of the tutorial is setting up the &lt;code&gt;Player&lt;/code&gt; scene. This is an
&lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_area2d.html&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_area_2d&#34; target=&#34;_blank&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_area_2d&#34;&gt;&lt;/svg&gt; &lt;code&gt;Area2D&lt;/code&gt;&lt;/a&gt; with
&lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_animatedsprite.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_animatedsprite&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_sprite&#34;&gt;&lt;/svg&gt;&lt;code&gt;AnimatedSprite&lt;/code&gt;&lt;/a&gt;
and &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_collisionshape2D.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_collision_shape_2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_collision_shape_2d&#34;&gt;&lt;/svg&gt;&lt;code&gt;CollisionShape2D&lt;/code&gt;&lt;/a&gt;
children.&lt;/p&gt;

&lt;p&gt;Adding the children led to a couple instances of this:
&lt;img src=&#34;/blog/blog/img/add_child_error.png&#34; width=&#34;250&#34;&gt;&lt;/p&gt;

&lt;p&gt;Students must be reminded to click on the desired parent node &lt;em&gt;before&lt;/em&gt; clicking
on &amp;ldquo;Add Node&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Adding the frames to the &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_animatedsprite.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_animatedsprite&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_sprite&#34;&gt;&lt;/svg&gt;&lt;code&gt;AnimatedSprite&lt;/code&gt;&lt;/a&gt;
went smoothly, but it was when adding the collision shape that some problems
started to appear.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/blog/blog/img/collision_offset_problem.png&#34; width=&#34;250&#34;&gt;&lt;/p&gt;

&lt;p&gt;It is far too easy and unnoticeable to wind up with the children offset and/or
scaled relative to the parent. Nearly every student had trouble with this in one
way or another. When looking at the collision shape, it is much too tempting and
easy to grab the rectangular handles and move/stretch it. When scaling the
capsule shape, if you don&amp;rsquo;t click exactly on the size handle, you wind up moving
the shape instead.&lt;/p&gt;

&lt;p&gt;I think that it must be emphasized &lt;em&gt;before&lt;/em&gt; adding a child that you probably
want to click the &amp;ldquo;lock children&amp;rdquo; button (which has a very mystifying icon, by
the way).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/blog/blog/img/lock_children.png&#34; width=&#34;450&#34;&gt;&lt;/p&gt;

&lt;h2 id=&#34;scripting&#34;&gt;Scripting&lt;/h2&gt;

&lt;p&gt;Once the player scene was created, it was time to add a script for movement. This
part went very smoothly. I spent a couple of minutes talking about the minor
differences between GDScript and Python (using &lt;code&gt;var&lt;/code&gt; to declare variables, and
&lt;code&gt;func&lt;/code&gt; instead of &lt;code&gt;def&lt;/code&gt; mainly), and we were off.&lt;/p&gt;

&lt;p&gt;The kids really liked the IDE. At the beginner level in my Python class, I don&amp;rsquo;t
like to have them use autocompletion, so this was a big plus for them. One
student declared that she&amp;rsquo;s never going to type a whole function name again! They
also liked the real-time error checking.&lt;/p&gt;

&lt;p&gt;Nothing in the code itself was a problem for them. Checking for key inputs,
normalizing velocity, and clamping to the screen were all familiar concepts. It
was a big help that I spend a lot of time in my Python class getting them used
to working with vectors, so I didn&amp;rsquo;t need to explain any of that.&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up-week-1&#34;&gt;Wrapping up Week 1&lt;/h2&gt;

&lt;p&gt;At this point we were out of time, so adding the enemies and the UI will have
to wait for next week&amp;rsquo;s class. They really didn&amp;rsquo;t want to stop, which I expected,
and they&amp;rsquo;re all excited for next week. I asked them what they thought so far and
they were all happy with the Godot experience.&lt;/p&gt;

&lt;p&gt;Long term, my goal with these students is to work through a couple of projects
together and then turn them loose to develop their own games. Two of the girls
really like working together and I expect they&amp;rsquo;ll want to collaborate on a game,
so we may even touch on some source control and project management topics.&lt;/p&gt;

&lt;h2 id=&#34;pain-points-for-me&#34;&gt;Pain points for me&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Dark UI&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dark UIs are great, I love them. But in the classroom, it means I did have
to turn the lights off in order for it to be at all visible using the projector.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Resolution&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Godot editor really likes to have a lot of screen space. My projector has a
native resolution of 1280x800, and that makes things pretty tight, especially
in the code editor. Adding a keyboard shortcut to toggle &amp;ldquo;Distraction Free Mode&amp;rdquo;
was a must.&lt;/p&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://godotengine.org&#34;&gt;Download Godot Engine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Us on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Godot - Animating Tiles Using Shaders</title>
      <link>/blog/2017/08/godot_tilemap_shaders/</link>
      <pubDate>Sun, 06 Aug 2017 15:22:12 PDT</pubDate>
      
      <guid>/blog/2017/08/godot_tilemap_shaders/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/blog/blog/img/godot_logo.png&#34; width=&#34;450&#34;&gt;&lt;/p&gt;

&lt;p&gt;&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/j2gJgFzg-yU&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;animated-tiles&#34;&gt;Animated Tiles&lt;/h2&gt;

&lt;p&gt;Our goal for this project is to create an animated tile that we can use in a Godot &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_tilemap.html&#34; target=&#34;_blank&#34;&gt;TileMap&lt;/a&gt; like this example:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;/blog/blog/img/anim_tile1.gif&#34; width=&#34;250&#34;&gt;&lt;/p&gt;

&lt;p&gt;It is possible to do this using an &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_animationplayer.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_animation_player&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_animation_player&#34;&gt;&lt;/svg&gt;AnimationPlayer&lt;/a&gt; node (see &lt;a href=&#34; https://youtu.be/jYTGvlCQd0E&#34; target=&#34;_blank&#34;&gt;this video&lt;/a&gt; for details).  However, for this lesson, we are instead going to implement the tile animation using a &lt;a href=&#34;http://docs.godotengine.org/en/2.1/learning/features/shading/shading_language.html&#34; target=&#34;_blank&#34;&gt;Shader&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;about-shaders&#34;&gt;About Shaders&lt;/h3&gt;

&lt;p&gt;If you&amp;rsquo;ve never encountered &lt;a href=&#34;https://en.wikipedia.org/wiki/Shader&#34; target=&#34;_blank&#34;&gt;shaders&lt;/a&gt; before, they can be very intimidating.  This is not intended to be a comprehensive introduction to the subject, so here are a few links to get you started:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://docs.godotengine.org/en/2.1/learning/features/shading/shading_language.html&#34;&gt;Godot shader reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://thebookofshaders.com/&#34;&gt;The Book of Shaders&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://notes.underscorediscovery.com/shaders-a-primer/&#34;&gt;Primer: Shaders&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;creating-a-new-shader&#34;&gt;Creating a new shader&lt;/h3&gt;

&lt;p&gt;We will start with a regular TileSet, which is just a collection of &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_sprite.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_sprite&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_sprite&#34;&gt;&lt;/svg&gt; Sprite&lt;/a&gt; nodes. You can use your own art, or download the &lt;a href=&#34;/blog/blog/img/anim_water.zip&#34;&gt;example water pack&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Add a new &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_sprite.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_sprite&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_sprite&#34;&gt;&lt;/svg&gt; Sprite&lt;/a&gt; and name it &lt;code&gt;water shader&lt;/code&gt;.  You can use any texture you like, as the image will be replaced when our shader is working.&lt;/p&gt;

&lt;p&gt;Add a shader to the sprite by adding a new &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_canvasitemmaterial.html&#34; target=&#34;_blank&#34;&gt;CanvasItemMaterial&lt;/a&gt; followed by a new &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_canvasitemshader.html&#34; target=&#34;_blank&#34;&gt;CanvasItemShader&lt;/a&gt; like so:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/create_shader.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/create_shader.gif&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;When you have done this, you will see a new pane open, with three tabs labeled &lt;code&gt;Vertex&lt;/code&gt;, &lt;code&gt;Fragment&lt;/code&gt;, and &lt;code&gt;Lighting&lt;/code&gt;.  We will be creating a &amp;ldquo;fragment&amp;rdquo; (aka pixel) shader, so make sure the correct tab is selected.&lt;/p&gt;

&lt;h3 id=&#34;shader-code&#34;&gt;Shader code&lt;/h3&gt;

&lt;p&gt;Shader code uses syntax similar to C.  We will start by defining our textures (the frames for the animation).  There are 3 animations in the pack, each with 5 frames.  We will focus on one to start with:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-glsl&#34; data-lang=&#34;glsl&#34;&gt;&lt;span class=&#34;k&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frame1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frame2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frame3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frame4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frame5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The &lt;code&gt;uniform&lt;/code&gt; keyword will expose the variable so that it can be set in the Inspector (similar to &lt;code&gt;export&lt;/code&gt; in GDScript).  If you look at the &lt;code&gt;CanvasItemMaterial&lt;/code&gt; now, you will see the 5 texture variables:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/shader_ex01.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/shader_ex01.png&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;Drag the 5 textures into the 5 slots in the Inspector.  Let&amp;rsquo;s test to see if it works:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-glsl&#34; data-lang=&#34;glsl&#34;&gt;&lt;span class=&#34;n&#34;&gt;COLOR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This just sets each pixel of the sprite to use the corresponding pixel of &lt;code&gt;frame1&lt;/code&gt;.  Change it to &lt;code&gt;frame2&lt;/code&gt; and observe the difference.&lt;/p&gt;

&lt;h3 id=&#34;incorporating-time&#34;&gt;Incorporating time&lt;/h3&gt;

&lt;p&gt;Now we need that process to change with respect to time.  In Godot, the &lt;code&gt;TIME&lt;/code&gt; variable will contain the current time (in seconds).  This value will steadily increase, but we are only interested in the fractional part, so we will use that:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-glsl&#34; data-lang=&#34;glsl&#34;&gt;&lt;span class=&#34;k&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;time&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fract&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TIME&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;color&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;col&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;col&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;COLOR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;col&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;We check if the time is less than 0.5 and then use the texture pixel as before. Now you should see texture #1 for half a second, and nothing for the other half.  The only remaining thing is to break the second in to 5 parts and set the texture based on which fraction we are in.  We will also add a &lt;code&gt;speed&lt;/code&gt; uniform to allow easy adjustment of the animation speed.  Here is the final shader code in full:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-glsl&#34; data-lang=&#34;glsl&#34;&gt;&lt;span class=&#34;k&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frame1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frame2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frame3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frame4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;texture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;frame5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;uniform&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;color&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;col&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;time&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fract&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TIME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;col&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;col&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;col&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;0.8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;n&#34;&gt;col&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;n&#34;&gt;col&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;frame5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;COLOR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;col&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&#34;creating-the-tileset&#34;&gt;Creating the tileset&lt;/h3&gt;

&lt;p&gt;Now it just remains to save the sprites as a TileSet (&lt;code&gt;Scene -&amp;gt; Convert To.. -&amp;gt; TileSet..&lt;/code&gt;) and load it in your &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_tilemap.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_tile_map&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_tile_map&#34;&gt;&lt;/svg&gt; TileMap&lt;/a&gt;.  You can use the tile like any other, but when placed it will animate.&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;Shaders are powerful, and this only scratches the surface of what you can do with them.  To learn more, see the links below to resources where you can learn more about how to create your own shader effects.&lt;/p&gt;

&lt;h3 id=&#34;a-href-https-github-com-kidscancode-godot-tutorials-releases-download-godot101-godot101-part-13-zip-project-files-a&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/godot_tutorials/releases/download/godot101/Godot101_Part_13.zip&#34;&gt;Project Files&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://godotengine.org&#34;&gt;Download Godot Engine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Us on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Godot 101 - Part 13: KinematicBody2D Collisions Done Right</title>
      <link>/blog/2017/06/godot_101_13/</link>
      <pubDate>Sat, 24 Jun 2017 05:22:12 PDT</pubDate>
      
      <guid>/blog/2017/06/godot_101_13/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/blog/blog/img/godot_logo.png&#34; width=&#34;450&#34;&gt;&lt;/p&gt;

&lt;p&gt;This is part 13 of &amp;ldquo;Godot 101&amp;rdquo;. In this installment, we take a deeper look at how to handle KinematicBody2D collisions in a simple and accurate way, and how to avoid a few common mistakes.  If you haven&amp;rsquo;t already read through the previous parts, please start with &lt;a href=&#34;http://kidscancode.org/blog/2017/02/godot_101_01/&#34;&gt;Part 1&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;about-this-series&#34;&gt;About this series&lt;/h3&gt;

&lt;p&gt;Godot 101 is an introduction to the Godot game engine and how it works. If you&amp;rsquo;ve never used a game engine before, or if you&amp;rsquo;re just new to Godot, this is the place to start.  If you&amp;rsquo;re new here, a quick note about this website: we&amp;rsquo;re called KidsCanCode because we teach programming and game development to kids, but if you&amp;rsquo;re an adult you&amp;rsquo;re welcome here, too.  We don&amp;rsquo;t believe in dumbing-down the material for kids, and game development is &lt;em&gt;hard&lt;/em&gt; - so it will probably be challenging no matter what your age.
&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/tkMSAme-BnY&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;doing-collisions-right&#34;&gt;Doing Collisions Right&lt;/h2&gt;

&lt;p&gt;We have seen before how the &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_kinematic_body_2D.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_kinematic_body_2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_kinematic_body_2d&#34;&gt;&lt;/svg&gt;&lt;code&gt;KinematicBody2D&lt;/code&gt;&lt;/a&gt;
node is perfect for implementing characters and other moving bodies that don&amp;rsquo;t need the full simulation of physics, but just need movement and collision detection.  And while collision detection is very simple in Godot (the physics bodies just take care of it), we also need to understand how to make the bodies &lt;em&gt;respond&lt;/em&gt; to collisions.&lt;/p&gt;

&lt;p&gt;The basic structure of a &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_kinematic_body_2D.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_kinematic_body_2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_kinematic_body_2d&#34;&gt;&lt;/svg&gt;&lt;code&gt;KinematicBody2D&lt;/code&gt;&lt;/a&gt; scene is this:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_kinematic_body_2d&#34;&gt;
&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_kinematic_body_2d&#34;&gt;&lt;/svg&gt; &lt;code&gt;KinematicBody2D&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_sprite&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_sprite&#34;&gt;&lt;/svg&gt; &lt;code&gt;Sprite&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_collision_shape_2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_collision_shape_2d&#34;&gt;&lt;/svg&gt; &lt;code&gt;CollisionShape2D&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;For the example in this demonstration, we&amp;rsquo;ll use a round image for the sprite, and a circular collision shape:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/ball.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/ball.png&#34; width=&#34;100&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When using a &lt;code&gt;KinematicBody2D&lt;/code&gt;, you must use the &lt;code&gt;move()&lt;/code&gt; method to change its position.  This method takes a &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_vector2.html&#34; target=&#34;_blank&#34;&gt;&lt;code&gt;Vector2&lt;/code&gt;&lt;/a&gt; as its argument, which represents the distance &amp;amp; direction you wish to move the body.  The method returns another &lt;code&gt;Vector2&lt;/code&gt; representing the motion remaining after a collision.  We then have two choices of how to respond to this collision.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at this process in more detail:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_13_01.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_13_01.png&#34; width=&#34;400&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;Here we see the gray vector representing the desired movement, which we will pass to the move method.  However, the green obstacle is in the way, so the move will stop when the collision occurs.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_13_02.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_13_02.png&#34; width=&#34;400&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;The red vector is the returned value of the &lt;code&gt;move()&lt;/code&gt; method: representing the amount of the movement that was unable to be completed.  Now we have a choice: to &lt;em&gt;slide&lt;/em&gt; the body along the obstacle (as if it were sticky) or to &lt;em&gt;reflect&lt;/em&gt; it off (i.e. bounce).  In either case, we need to know the obstacle&amp;rsquo;s &lt;code&gt;normal&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_13_03.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_13_03.png&#34; width=&#34;400&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;normal&lt;/code&gt; vector is a unit-length vector pointing perpendicularly away from a surface.  This vector tells us what direction the surface is facing (for example which edge of a shape was hit).  Using this vector we can calculate the response.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_13_04.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_13_04.png&#34; width=&#34;400&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;If we wish the body to slide along the object&amp;rsquo;s surface, we use &lt;code&gt;n.slide()&lt;/code&gt; and if we want it to bounce, we use &lt;code&gt;n.reflect()&lt;/code&gt;.  Note that the length of the resulting vector when using &lt;code&gt;slide()&lt;/code&gt; is only the &lt;em&gt;component&lt;/em&gt; of the remaining motion in the desired direction.&lt;/p&gt;

&lt;h3 id=&#34;seeing-it-in-action&#34;&gt;Seeing it in action&lt;/h3&gt;

&lt;p&gt;Here is an example using the &lt;code&gt;reflect()&lt;/code&gt; option:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_13_05.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_13_05.gif&#34; width=&#34;400&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;Note that not only flat surfaces have normals. Curved surfaces have a different normal at each point, resulting in a proper looking bounce off a round object:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_13_06.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_13_06.gif&#34; width=&#34;400&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;On the other hand, if we switch to slide mode, the result looks like this:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_13_07.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_13_07.gif&#34; width=&#34;400&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;Note how the velocity vectors are much shorter, especially if the collision angle is steep.&lt;/p&gt;

&lt;h3 id=&#34;the-code&#34;&gt;The code&lt;/h3&gt;

&lt;p&gt;Here is the code for the ball object, including both kinds of collision response:&lt;/p&gt;

&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;n&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KinematicBody2D&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Vector2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# pixels/sec&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# set this to &amp;lt; 1.0 to demonstrate loss of energy&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bounce_coefficent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.0&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# this toggles reflect or slide mode&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;reflect&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_ready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;randomize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;# set start velocity towards mouse position&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;vel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_global_mouse_pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_pos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;normalized&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;speed&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;set_fixed_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_fixed_process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;# move the body&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;motion&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is_colliding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;# find the normal&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_collision_normal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;# reflect the motion *and* the velocity&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;motion&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;motion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;vel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;reflect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bounce_coefficent&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;# or slide them&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;motion&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;slide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;motion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;vel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;slide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;vel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;# remember to also move by the resulting motion&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;move&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;motion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;This should be self-explanatory.  Note that we reflect/slide both the remaining motion vector (so that the movement is continued) &lt;em&gt;and&lt;/em&gt; the velocity vector (so that it is now moving in the proper direction).&lt;/p&gt;

&lt;h2 id=&#34;important-read-this&#34;&gt;IMPORTANT: Read this!&lt;/h2&gt;

&lt;p&gt;Are your collisions doing this?&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_13_08.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_13_08.gif&#34; width=&#34;400&#34;&gt;&lt;/a&gt;&lt;sub&gt;Click to enlarge&lt;/sub&gt;&lt;/p&gt;

&lt;p&gt;One of the most common mistakes we see among beginners when using physics bodies is incorrectly scaling the nodes.  For example, when creating the circular collision shape for the ball, you must use the &lt;em&gt;inner&lt;/em&gt; size handle to set the shape&amp;rsquo;s size.  Never use the outer rectangle, or you will cause the node to be scaled.&lt;/p&gt;

&lt;p&gt;If you have &amp;ldquo;glitchy&amp;rdquo; collisions, this is most likely the cause.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NEVER SCALE A PHYSICS BODY OR COLLISION SHAPE!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Always make sure that the &lt;code&gt;KinematicBody2D&lt;/code&gt; &lt;em&gt;and&lt;/em&gt; the &lt;code&gt;CollisionShape2D&lt;/code&gt; have their &lt;code&gt;scale&lt;/code&gt; property set to &lt;code&gt;(1, 1)&lt;/code&gt;.  Always.&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;Good collision response is easy if you follow a few simple rules, and take advantage of Godot&amp;rsquo;s built-in functions. If you&amp;rsquo;d like to experiment with the code used for the examples here, you can download the full project, or click the link below for the source code.&lt;/p&gt;

&lt;h3 id=&#34;a-href-https-github-com-kidscancode-godot-tutorials-releases-download-godot101-godot101-part-13-zip-collision-example-project-a&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/godot_tutorials/releases/download/godot101/Godot101_Part_13.zip&#34;&gt;Collision example project&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;a-href-https-github-com-kidscancode-godot-tutorials-tree-master-godot101-code-for-this-part-a&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/godot_tutorials/tree/master/Godot101&#34;&gt;Code for this part&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;a-href-godot-101-part-14-coming-soon-a&#34;&gt;&lt;a href=&#34;&#34;&gt;Godot 101 - Part 14 (coming soon)&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://godotengine.org&#34;&gt;Download Godot Engine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Us on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Godot 101 - Part 12: Camera and Scrolling Background</title>
      <link>/blog/2017/04/godot_101_12/</link>
      <pubDate>Sat, 15 Apr 2017 05:22:12 PDT</pubDate>
      
      <guid>/blog/2017/04/godot_101_12/</guid>
      <description>&lt;p&gt;&lt;img src=&#34;/blog/blog/img/godot_logo.png&#34; width=&#34;450&#34;&gt;&lt;/p&gt;

&lt;p&gt;This is part 12 of &amp;ldquo;Godot 101&amp;rdquo;. In this installment, we add a camera to follow the player, and make a scrolling background.  If you haven&amp;rsquo;t already read through the previous parts, please start with &lt;a href=&#34;http://kidscancode.org/blog/2017/02/godot_101_01/&#34;&gt;Part 1&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;about-this-series&#34;&gt;About this series&lt;/h3&gt;

&lt;p&gt;Godot 101 is an introduction to the Godot game engine and how it works. If you&amp;rsquo;ve never used a game engine before, or if you&amp;rsquo;re just new to Godot, this is the place to start.  If you&amp;rsquo;re new here, a quick note about this website: we&amp;rsquo;re called KidsCanCode because we teach programming and game development to kids, but if you&amp;rsquo;re an adult you&amp;rsquo;re welcome here, too.  We don&amp;rsquo;t believe in dumbing-down the material for kids, and game development is &lt;em&gt;hard&lt;/em&gt; - so it will probably be challenging no matter what your age.
&lt;/p&gt;

&lt;p&gt;You can watch a video version of this lesson here:
&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/quVFPh1eotE&#34; frameborder=&#34;0&#34; allowfullscreen&gt;&lt;/iframe&gt;&lt;/p&gt;

&lt;h2 id=&#34;a-bigger-world&#34;&gt;A Bigger World&lt;/h2&gt;

&lt;p&gt;Start by going to your &lt;code&gt;main&lt;/code&gt; scene and duplicating the platform instance 2 more times.  Take the new instances and arrange them to the right like this:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_12_01.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_12_01.png&#34; width=&#34;450&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now we have a much bigger &amp;ldquo;level&amp;rdquo; to run around in, but we can&amp;rsquo;t get to the new platforms because they&amp;rsquo;re off the screen. We need a &amp;ldquo;camera&amp;rdquo; that will track the player wherever he goes.  This is easily done in Godot using the &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_camera2d.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_camera_2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_camera_2d&#34;&gt;&lt;/svg&gt;&lt;code&gt;Camera2D&lt;/code&gt;&lt;/a&gt; node.&lt;/p&gt;

&lt;p&gt;Switch to your &lt;code&gt;player&lt;/code&gt; scene and add a &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_camera2d.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_camera_2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_camera_2d&#34;&gt;&lt;/svg&gt;&lt;code&gt;Camera2D&lt;/code&gt;&lt;/a&gt; - I named mine &lt;code&gt;camera&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Here is what you&amp;rsquo;ll see in the Inspector:
&lt;a href=&#34;/blog/blog/img/godot101_12_02.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_12_02.png&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;In order for the camera to work, you must current the &lt;code&gt;Current&lt;/code&gt; property. It is possible to have multiple cameras in a scene, but only one can be &lt;code&gt;Current&lt;/code&gt;, and that is the one the game window will track.  That&amp;rsquo;s it!  Hit play and now you have a camera locked to the player:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_12_03.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_12_03.gif&#34; width=&#34;450&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Feel free to experiment with the other camera settings in the Inspector.  &lt;code&gt;Smoothing&lt;/code&gt; controls how the camera &amp;ldquo;catches up&amp;rdquo; to the player when it moves, and the &lt;code&gt;Drag Margin&lt;/code&gt; settings will let you adjust how close to the edge of the window the player can get before the camera moves.&lt;/p&gt;

&lt;h3 id=&#34;repeating-the-background&#34;&gt;Repeating the Background&lt;/h3&gt;

&lt;p&gt;Now we need to fix the issue of the background only covering part of the world.  What we want is for the background image to repeat itself as we scroll to the right.  So let&amp;rsquo;s adjust our background texture so Godot knows it can be tiled:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_12_04.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_12_04.gif&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;When you check the &amp;lsquo;Region&amp;rsquo; property, the background disappears!  Don&amp;rsquo;t worry, we need to fill in the &lt;code&gt;Region Rect&lt;/code&gt; property as well.  Set the width and height (&lt;code&gt;w&lt;/code&gt; and &lt;code&gt;h&lt;/code&gt;) to &lt;code&gt;(3072*4, 1536)&lt;/code&gt; and now you will see a long repeating texture.&lt;/p&gt;

&lt;h2 id=&#34;parallax-scrolling&#34;&gt;Parallax Scrolling&lt;/h2&gt;

&lt;p&gt;Finally, let&amp;rsquo;s add a really cool effect: parallax scrolling.  This means we want to have our background scroll at a different speed from the foreground.  Specifically, if we have it move &lt;em&gt;slower&lt;/em&gt;, it will give the impression that it is much farther away.  As you might expect, Godot has a node (actually, 2 nodes) for that.&lt;/p&gt;

&lt;p&gt;Switch to the &lt;code&gt;main&lt;/code&gt; scene and add a &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_parallaxbackground.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_parallax_background&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_parallax_background&#34;&gt;&lt;/svg&gt;&lt;code&gt;ParallaxBackground&lt;/code&gt;&lt;/a&gt; node.  Drag it to the top of the tree.&lt;/p&gt;

&lt;p&gt;This node controls parallax scrolling, but you might want to have more than one layer of scrolling background.  For this reason, the &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_parallaxbackground.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_parallax_background&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_parallax_background&#34;&gt;&lt;/svg&gt;&lt;code&gt;ParallaxBackground&lt;/code&gt;&lt;/a&gt; node needs to contain one or more &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_parallaxlayer.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_parallax_layer&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_parallax_layer&#34;&gt;&lt;/svg&gt;&lt;code&gt;ParallaxLayer&lt;/code&gt;&lt;/a&gt; nodes.  Add one to the tree, and make the &lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_sprite&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_sprite&#34;&gt;&lt;/svg&gt; &lt;code&gt;background&lt;/code&gt; its child.  Your scene tree should now look like this:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_12_05.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_12_05.png&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;The properties of the &lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_parallax_layer&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_parallax_layer&#34;&gt;&lt;/svg&gt;&lt;code&gt;ParallaxLayer&lt;/code&gt; are straightforward:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_12_06.png&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_12_06.png&#34; width=&#34;200&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;motion/scale&lt;/code&gt; is what we want to change to adjust the movement speed of the background.  Change it to &lt;code&gt;(0.5, 0.5)&lt;/code&gt; and hit &amp;lsquo;Play&amp;rsquo;:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;/blog/blog/img/godot101_12_07.gif&#34;&gt;&lt;img src=&#34;/blog/blog/img/godot101_12_07.gif&#34; width=&#34;450&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;wrapping-up&#34;&gt;Wrapping up&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&#34;http://docs.godotengine.org/en/stable/classes/class_camera2d.html&#34; target=&#34;_blank&#34;&gt;&lt;svg width=&#34;18&#34; height=&#34;18&#34; class=&#34;icon-icon_camera_2d&#34;&gt;&lt;use xlink:href=&#34;/blog/img/symbol-defs.svg#icon-icon_camera_2d&#34;&gt;&lt;/svg&gt;&lt;code&gt;Camera2D&lt;/code&gt;&lt;/a&gt; node in Godot is incredibly easy to use.  In combination with parallax scrolling, it&amp;rsquo;s possible to get a very rich visual effect with very little effort.&lt;/p&gt;

&lt;h3 id=&#34;a-href-https-github-com-kidscancode-godot-tutorials-tree-master-godot101-full-code-for-this-part-a&#34;&gt;&lt;a href=&#34;https://github.com/kidscancode/godot_tutorials/tree/master/Godot101&#34;&gt;Full code for this part&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;a-href-blog-2017-06-godot-101-13-godot-101-part-13-a&#34;&gt;&lt;a href=&#34;/blog/blog/2017/06/godot_101_13/&#34;&gt;Godot 101 - Part 13&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;helpful-links&#34;&gt;Helpful Links:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://godotengine.org&#34;&gt;Download Godot Engine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.patreon.com/kidscancode&#34;&gt;Support Us on Patreon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
